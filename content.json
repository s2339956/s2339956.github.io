{"meta":{"title":"Tin Blog","subtitle":"星星給予仰望者光芒","description":"哲人無憂，智者常樂。並不是因為所愛的一切他都擁有了，而是所擁有的一切他都愛。","author":"Tin","url":"http://s2339956.github.io"},"pages":[{"title":"","date":"2021-04-29T05:32:29.136Z","updated":"2017-11-16T06:14:21.000Z","comments":true,"path":"google999895523f425ec1.html","permalink":"http://s2339956.github.io/google999895523f425ec1.html","excerpt":"","text":"google-site-verification: google999895523f425ec1.html","raw":null,"content":null},{"title":"404 Not Found：該頁無法顯示, 請嘗試聯繫作者","date":"2021-04-29T05:32:29.136Z","updated":"2017-11-15T09:35:26.000Z","comments":false,"path":"/404.html","permalink":"http://s2339956.github.io/404.html","excerpt":"","text":"","raw":null,"content":null},{"title":"about","date":"2017-11-14T14:18:56.000Z","updated":"2019-08-14T05:54:47.747Z","comments":true,"path":"about/index.html","permalink":"http://s2339956.github.io/about/index.html","excerpt":"","text":"技能清單 app 開發：Swift/ Objective-C iOS 開發工具: Xcode/ Fabric/ firebase/ lldb/ Reveal 版本管理：Git/ SourceTree 自動化：(xcodebuild/ shell)腳本打包上架 其他：Python/ LineBot/ Postman/ shell 反編譯：ida pro/ Hopper/ logos/ CaptainHook/ LLVM 工作經歷##（ 2016年6月 ~ 2018年九月 ） ios app 项目 橋接 Objective-C 與 swift 混和編譯產生的衝突, 例如 objC 取用 swift 全域變數 重構 專案中重複程式碼, 讓程式碼能重複使用, 引入設計模式的工廠模式, 使用緩加載優化 app, 減少記憶體使用, 全面改為 autolayout 自適應各種機型, 管理 採用 cocoapod 管理相關套件, 解決多人開發等問題 除錯 解決 callback 物件被咬死導致記憶體未能釋放, 採用 Fabric 紀錄使用者閃退等資訊, 修正相關錯誤提升使用者體驗 資料 使用 Realm 重構原本 CoreData, 包含未能刪除舊資料與資料格式新增欄位合併, 使用 Kingfisher 來處圖片儲存與替換緩存等問題, 並調整成緩存減少載入資料時的等待, 解決聊天室資料即時同步問題, 引入 signalR, 重構 ojbC Http Request Json 資料取用, 改為物件來操作 自動化 撰寫 Shell Scripts 自動打包上傳到 Appstore 腳本文件 ##（ 2016年1月 ~ 2016年4月 ） ios app 项目 升級 將原本語言 swift1 升級轉換至 swift2.2, 提交上架 除錯 使用 Optional 來保護 app, 避免伺服器請求時出現 json tag nil 重構 重新配置 autolayout 來適應 plus, 解決在大螢幕時畫面物件距離比例問題 Git SourceTree 來控管版本等 作品集 愛奇藝 iphone app 去廣告(免越獄安裝版) 台北搭捷運 app 遮蔽廣告(免越獄安裝版) VAC 交友 app 自由時報 app 愛健康 app Yes123 求職版 企業版 app Yes123 打卡系統 app (無上架) 記者發稿系統 (無上架) 車隊定位追蹤 app (無上架) 鐵捲門遙控 app (無上架) 地球村美日語 app 整合 Logos 語言至 Xcode（高亮模糊提示） 越獄插件 - 完美繞過全聯 PX Pay 越獄偵測機制，讓你完美使用全聯App 演講和講義 swift 線上讀書會 - 分享 iOS 逆向工程- Reveal基礎入門 IT-Home2019資安大會 - 在iOS 系統架構下，你的app 真的無堅不摧？讓我們一起來看app 裸奔吧 逢甲大學黑客社 - 概述iOS逆向攻擊 2019亞太資訊安全論壇 - 雙平台下被刻板印象所忽略的手機app漏洞 聯繫方式 Email：s2339956@gmail.com WeChat：s2339956 Line：s2339956","raw":null,"content":null},{"title":"tags","date":"2017-11-15T09:28:59.000Z","updated":"2017-11-15T09:28:59.920Z","comments":true,"path":"tags/index.html","permalink":"http://s2339956.github.io/tags/index.html","excerpt":"","text":"","raw":null,"content":null}],"posts":[{"title":"iOS tweak run in Simulator","slug":"iOS_tweak_run_in_simulator","date":"2022-03-18T06:26:45.000Z","updated":"2022-03-18T07:14:53.972Z","comments":true,"path":"iOS_tweak_run_in_simulator.html","link":"","permalink":"http://s2339956.github.io/iOS_tweak_run_in_simulator.html","excerpt":"　　iOS tweak run in Simulator","text":"iOS tweak run in Simulator 模擬器測試的優點 功能基本和實體機一樣 模擬器無需越獄，因此可以在新系統無法越獄時第一時間進行適配 可測試各種 iOS 版本、設備 繼承模擬器本身的優點 測試環境 x64 macOS(11.5.2) Xcode 12.4 Simulator(iphone 11 pro) 工具 theos: 編譯工具 simject: 作為Tweak Loader加載我們的dylib substitute: CydiaSubstrate python 3.6 ~ 3.8 原理: 使用 Theos 編譯出模擬器架構(x86_64)的 dylib，由 simject 進行加載。arm 上是由 CydiaSubstrate 為我們進行加載的。 步驟安裝 simject git clone https://github.com/angelXwind/simject.git cd simject/ make setup 安裝後會新增資料夾 /opt/simject 實質是對應實體機上的 /Library/MobileSubstrate/DynamicLibraries，後續把編譯完成的 dylib 和 plist 放在這裡，simject 就會幫我們加載。 安裝後會新增命令行工具 resim, 類似 sbreload，可用於重啓模擬器的 SpringBoard。 每個模擬器啓動後，並不會自動加載 simject，每次都需要執行 resim 一次，之後僅需在需要 sbreload 時再 resim 安裝Cydia Substratesimject 提供了一個腳本幫我們自動安裝好 Cydia Substrate 如果是Xcode 10 或者 以上 sudo ./installsubstrate.sh subst Xcode10 以下 使用 sudo ./installsubstrate.sh cs 測試simject 提供了 simjectExampleTweak 這個 demo 供我們進行測試 cd simjectExampleTweak 在 Makefile 中加入 TARGET = simulator:clang::7.0 、_LOGOSFLAGS += -c、generator=MobileSubstrate make setup cp -R simject/simjectExampleTweak/.theos/obj/iphone_simulator/x86_64/simjectExampleTweak.dylib /opt/simject/ cp -R simject/simjectExampleTweak/simjectExampleTweak.plist opt/simject/ 打開模擬器(Simulator) resim 可以看到模擬器已被重啓，並彈出了一個 AlertView 注意Tweak 每次重新編譯後，都需要重新複製到 opt/simject/，請先刪除原有檔案，在複製進去，否則會 crash loop","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"tweak","slug":"iOS/tweak","permalink":"http://s2339956.github.io/categories/iOS/tweak/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"tweak","slug":"tweak","permalink":"http://s2339956.github.io/tags/tweak/"}]},{"title":"Sublime Text save file is readonly","slug":"sublimetext_save_file_is_readonly","date":"2021-08-31T03:53:32.000Z","updated":"2021-08-31T06:34:59.221Z","comments":true,"path":"sublimetext_save_file_is_readonly.html","link":"","permalink":"http://s2339956.github.io/sublimetext_save_file_is_readonly.html","excerpt":"　　Sublime Text save file is readonly","text":"Sublime Text save file is readonly 修改並儲存 hosts(/private/etc/hosts) 時，出現 1Unable to save /private/etc/hosts Error: /private/etc/hosts is readonly mac os : 11.5.2（20G95） sublime Text : 41113 上網搜索對 Sublime 添加權限等等，都沒有效果… 解決辦法 對其檔案設置權限 改用 BBedit 來進行編輯儲存","raw":null,"content":null,"categories":[{"name":"mac","slug":"mac","permalink":"http://s2339956.github.io/categories/mac/"},{"name":"sublimetext","slug":"mac/sublimetext","permalink":"http://s2339956.github.io/categories/mac/sublimetext/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://s2339956.github.io/tags/mac/"},{"name":"sublimetext","slug":"sublimetext","permalink":"http://s2339956.github.io/tags/sublimetext/"}]},{"title":"Sublime text opne plist file","slug":"sublimetext_opne_plist_file","date":"2021-05-11T03:13:55.000Z","updated":"2021-05-11T03:18:43.309Z","comments":true,"path":"sublimetext_opne_plist_file.html","link":"","permalink":"http://s2339956.github.io/sublimetext_opne_plist_file.html","excerpt":"　　Sublime text opne plist file","text":"Sublime text opne plist file package: BinaryPlist install： Tool -&gt; Command Palette -&gt; Type package control::install package -&gt; Type binary plist","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"mac","slug":"iOS/mac","permalink":"http://s2339956.github.io/categories/iOS/mac/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"mac","slug":"mac","permalink":"http://s2339956.github.io/tags/mac/"}]},{"title":"Frida Error note","slug":"firda_error","date":"2020-12-18T03:24:22.000Z","updated":"2020-12-18T03:37:35.107Z","comments":true,"path":"firda_error.html","link":"","permalink":"http://s2339956.github.io/firda_error.html","excerpt":"　　Frida Error","text":"Frida Error 運行 frida-ps -Uai 就會噴出以下錯誤 123(frida:12957): Frida-CRITICAL **: 10:47:11.886: file ../../../frida-core/lib/interfaces/session.vala: line 167: uncaught error: GDBus.Error:org.freedesktop.DBus.Error.UnknownMethod: No such interface “re.frida.HostSession12” on object at path /re/frida/HostSession (g-dbus-error-quark, 19) Mac OS 版本為 1Big Sur 11.0.1（20B50） frida 版本為 12frida --version12.8.0 iOS frida 版本為 114.1.3 解法: 更新 frida 為匹配版本 frida-14.1.3 123sudo -H pip3 install --upgrade fridasudo -H pip3 install --upgrade frida-tools 123456789101112131415161718192021WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.To avoid this problem you can invoke Python with &#x27;-m pip&#x27; instead of running pip directly.Defaulting to user installation because normal site-packages is not writeableRequirement already satisfied: frida in /Users/tinxie/Library/Python/3.7/lib/python/site-packages (12.10.4)Collecting frida Downloading frida-14.1.3.tar.gz (7.5 kB)Building wheels for collected packages: frida Building wheel for frida (setup.py) ... done Created wheel for frida: filename=frida-14.1.3-cp37-cp37m-macosx_10_9_x86_64.whl size=13544424 sha256=c71c579feb9486ae6f83d0553f135165fa75b446a76640d4e1779b9ab8e34c9f Stored in directory: /Users/tinxie/Library/Caches/pip/wheels/b3/c1/d8/881183b64dcb20af479a2282454d65390369bbe25cde6f055eSuccessfully built fridaInstalling collected packages: frida Attempting uninstall: frida Found existing installation: frida 12.10.4 Uninstalling frida-12.10.4: Successfully uninstalled frida-12.10.4ERROR: pip&#x27;s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.frida-tools 5.3.0 requires frida&lt;13.0.0,&gt;=12.7.3, but you have frida 14.1.3 which is incompatible.frida-tools 5.3.0 requires prompt-toolkit&lt;3.0.0,&gt;=2.0.0, but you have prompt-toolkit 3.0.5 which is incompatible.Successfully installed frida-14.1.3 搞定收工！","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"frida","slug":"frida","permalink":"http://s2339956.github.io/tags/frida/"}]},{"title":"常用端口號紀錄","slug":"常用端口號紀錄","date":"2020-12-17T08:09:23.000Z","updated":"2020-12-17T08:13:03.410Z","comments":true,"path":"常用端口號紀錄.html","link":"","permalink":"http://s2339956.github.io/%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E8%99%9F%E7%B4%80%E9%8C%84.html","excerpt":"　　常用端口號紀錄","text":"常用端口號紀錄 HTTP協議代理伺服器常用 port : 80/ 8080/ 3128/ 8081/ 9080 SOCKS代理協議伺服器常用 port : 1080 FTP(文件傳輸)協議代理伺服器常用 port : 21 Telnet(遠程登錄)協議代理伺服器常用 port : 23 HTTP伺服器, 默認的 port 為80/ tcp(木馬Executor開放此端口); HTTPS(securely transferring web pages)伺服器, 默認的 port 為443/ tcp 443/ udp; Telnet(不安全的文本傳送), 默認 port 為23/ tcp(木馬Tiny Telnet Server所開放的端口); FTP, 默認的 port 為21/ tcp(木馬Doly Trojan, Fore, Invisible FTP, WebEx, WinCrash和Blade Runner所開放的端口); TFTP(Trivial File Transfer Protocol), 默認的 port 為69/ udp; SSH(安全登錄), SCP(文件傳輸), 端口重定向, 默認的 port 為22/ tcp; SMTP Simple Mail Transfer Protocol (E-mail), 默認的 port 為25/ tcp(木馬Antigen、Email Password Sender, Haebu Coceda, Shtrilitz Stealth, WinPC, WinSpy都開放這個端口); POP3 Post Office Protocol (E-mail), 默認的 port 為110/ tcp; WebLogic, 默認的 port 為7001; Webshpere應用程序, 默認的 port 為9080; webshpere管理工具, 默認的 port 為9090; JBOSS, 默認的 port 為8080; TOMCAT, 默認的 port 為8080; WIN2003遠程登陸, 默認的 port 為3389; Symantec AV/ Filter for MSE,默認 port 為 8081; Oracle 數據庫, 默認的 port 為1521; ORACLE EMCTL, 默認的 port 為1158; Oracle XDB(XML 數據庫), 默認的 port 為8080; Oracle XDB FTP服務, 默認的 port 為2100; MS SQLSERVER數據庫server, 默認的 port 為1433/ tcp 1433/ udp; MS SQLSERVER數據庫monitor, 默認的 port 為1434/ tcp 1434/ udp;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"sysctl 系統內核函數","slug":"sysctl_系統內核函數","date":"2020-12-01T08:53:23.000Z","updated":"2020-12-01T09:00:20.571Z","comments":true,"path":"sysctl_系統內核函數.html","link":"","permalink":"http://s2339956.github.io/sysctl_%E7%B3%BB%E7%B5%B1%E5%85%A7%E6%A0%B8%E5%87%BD%E6%95%B8.html","excerpt":"　　sysctl 系統內核函數","text":"sysctl 系統內核函數 sysctl 系統內核函數sysctl 用於系統的檢測和控制，監控進程是否被附加或者調試(debug)。 定義定時器，每幾秒檢測一下app是否被附加(注入)。 1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F; 定時器輪詢查詢app是否被調試，每秒鐘檢查一次static dispatch_source_t timer;BOOL isDebugger() &#123; int name[4]; name[0] &#x3D; CTL_KERN; &#x2F;&#x2F; 內核 name[1] &#x3D; KERN_PROC; &#x2F;&#x2F; 查詢進程 name[2] &#x3D; KERN_PROC_PID; &#x2F;&#x2F; 通過進程ID查詢 name[3] &#x3D; getpid(); &#x2F;&#x2F; 獲取進程ID struct kinfo_proc info; &#x2F;&#x2F; 進程查詢結果的結構體 size_t info_size &#x3D; sizeof(info); &#x2F;&#x2F; 結構體大小 int error &#x3D; sysctl(name, sizeof(name)&#x2F;sizeof(*name), &amp;info, &amp;info_size, 0, 0); assert(error &#x3D;&#x3D; 0); &#x2F;&#x2F; 0就是沒有錯誤，其他就是錯誤碼 &#x2F;&#x2F; (info.kp_proc.p_flag &amp; P_TRACED) !&#x3D; 0; &#x2F;&#x2F; 0沒有調試 !&#x3D;0有調試 return ((info.kp_proc.p_flag &amp; P_TRACED) !&#x3D; 0);&#125;+ (void)load &#123; timer &#x3D; dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_global_queue(0, 0)); dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); dispatch_source_set_event_handler(timer, ^&#123; if (isDebugger()) &#123; exit(0); &#125; &#125;); dispatch_resume(timer);&#125;","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"了解什麼是NAT機制","slug":"了解什麼是NAT機制","date":"2020-09-21T02:22:10.000Z","updated":"2020-09-21T02:22:51.845Z","comments":true,"path":"了解什麼是NAT機制.html","link":"","permalink":"http://s2339956.github.io/%E4%BA%86%E8%A7%A3%E4%BB%80%E9%BA%BC%E6%98%AFNAT%E6%A9%9F%E5%88%B6.html","excerpt":"　　了解什麼是NAT機制？","text":"了解什麼是NAT機制？ 了解什麼是NAT機制？網絡地址轉換（Network Address Translation，NAT）機制的問題在於，NAT設備自動屏蔽了非內網主機主動發起的連接，也就是說，從外網發往內網的數據包將被NAT設備丟棄，這使得位於不同NAT設備之後的主機之間無法直接交換信息。這一方面保護了內網主機免於來自外部網絡的攻擊，另一方面也為P2P通信帶來了一定困難。外部主機要與內網主機相互通信，必須由內網主機主動發起連接，使 NAT設備產生一個映射條目，這就有必要研究一下內網穿透技術。","raw":null,"content":null,"categories":[{"name":"Network","slug":"Network","permalink":"http://s2339956.github.io/categories/Network/"}],"tags":[{"name":"Network","slug":"Network","permalink":"http://s2339956.github.io/tags/Network/"}]},{"title":"Docker - 在容器中搭建 FTP 伺服器 (vsftpd)","slug":"Docker-在容器中搭建FTP伺服器(vsftpd)","date":"2020-08-07T09:10:50.000Z","updated":"2020-08-07T09:35:50.949Z","comments":true,"path":"Docker-在容器中搭建FTP伺服器(vsftpd).html","link":"","permalink":"http://s2339956.github.io/Docker-%E5%9C%A8%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%90%AD%E5%BB%BAFTP%E4%BC%BA%E6%9C%8D%E5%99%A8(vsftpd).html","excerpt":"　　Docker - 在容器中搭建 FTP 伺服器 (vsftpd)","text":"Docker - 在容器中搭建 FTP 伺服器 (vsftpd) 使用 Docker 搭建 FTP 服務，不僅十分簡單，而且可以對宿主機有一定的隔離。下面以 CentOS 系統為例，演示如何通過容器運行 FTP 服務。 拉取鏡像首先執行如下命令將鏡像下載至電腦： 1docker pull fauria&#x2F;vsftpd 啓動容器執行如下命令實例化 FTP 服務： 1234567參數說明：&#x2F;home&#x2F;ftp:&#x2F;home&#x2F;vsftpd: 映射 docker 容器 FTP 文件根目錄（冒號前面是宿主機的目錄）-p: 映射 docker 端口（冒號前面是宿主機的端口）-e FTP_USER&#x3D;test -e FTP_PASS&#x3D;test : 設置默認的用戶名密碼（都為 test）PASV_ADDRESS : 宿主機 ip，當需要使用被動模式時必須設置。PASV_MIN_PORT~ PASV_MAX_PORT : 給客服端提供下載服務隨機端口號範圍，默認 21100-21110，與前面的 docker 端口映射設置成一樣。 123456docker run -d -v &#x2F;home&#x2F;ftp:&#x2F;home&#x2F;vsftpd \\-p 20:20 -p 21:21 -p 21100-21110:21100-21110 \\-e FTP_USER&#x3D;test -e FTP_PASS&#x3D;test \\-e PASV_ADDRESS&#x3D;192.168.60.128 \\-e PASV_MIN_PORT&#x3D;21100 -e PASV_MAX_PORT&#x3D;21110 \\--name vsftpd --restart&#x3D;always fauria&#x2F;vsftpd 防火牆配置 如果 CentOS 服務器有防火牆，為了讓客戶端能夠訪問 FTP 服務。 我們可以關閉防火牆，或者執行如下命令配置 firewall 防火牆策略： (此步驟可忽略) 1234567891011121314firewall-cmd --permanent --add-port&#x3D;20&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21100&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21101&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21102&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21103&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21104&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21105&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21106&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21107&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21108&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21109&#x2F;tcpfirewall-cmd --permanent --add-port&#x3D;21110&#x2F;tcpfirewall-cmd --reload 新建用戶文件夾 (1) 首先執行如下命令進入到容器裡面： 1docker exec -i -t vsftpd bash (2) 由於前面我們啓動的時候設置用戶名為 test，已經自動創建對應的用戶文件夾（所以下面這個文件夾無需我們再次手動創建）： 1mkdir &#x2F;home&#x2F;vsftpd&#x2F;test (3) 為方便演示，在 test 用戶文件夾下新建一個 1.txt 文件。 1vi &#x2F;home&#x2F;vsftpd&#x2F;test&#x2F;1.txt 訪問服務 （1）我們可以直接使用瀏覽器進行訪問，地址如下： 1ftp:&#x2F;&#x2F;test:test@192.168.60.128:21 （2）也可以使用 FTP 客戶端工具進行訪問。 （3）如果是 MacOS，我們還可以通過「Finder」-&gt;「前往」-&gt;「連接伺服器…」來訪問 FTP 服務。 附：增加一個新用戶前面我們在啓動服務的時候就創建了個默認用戶 test。如果需要新增一個新用戶，假設用戶名稱：tinxie，密碼：123456，具體操作如下。 （1）首先執行如下命令進入到容器裡面： 1docker exec -i -t vsftpd bash （2）創建新用戶的資料夾： 1mkdir &#x2F;home&#x2F;vsftpd&#x2F;tinxie （3）編輯用戶配置文件： 1vi &#x2F;etc&#x2F;vsftpd&#x2F;virtual_users.txt （4）在文件中新增新用戶的用戶名和密碼： （5）保存退出後執行如下命令，把登錄的驗證資訊寫入資料庫。 1&#x2F;usr&#x2F;bin&#x2F;db_load -T -t hash -f &#x2F;etc&#x2F;vsftpd&#x2F;virtual_users.txt &#x2F;etc&#x2F;vsftpd&#x2F;virtual_users.db （6）最後退出容器，並重啓容器可以使用新用戶連接 FTP 服務了。 12exitdocker restart vsftpd","raw":null,"content":null,"categories":[{"name":"Docker","slug":"Docker","permalink":"http://s2339956.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://s2339956.github.io/tags/Docker/"}]},{"title":"(轉) IDA Pro 7.3 Release v1.0","slug":"IDA_Pro_7.3_Release_v1.0","date":"2020-08-07T09:10:50.000Z","updated":"2020-08-07T09:42:00.254Z","comments":true,"path":"IDA_Pro_7.3_Release_v1.0.html","link":"","permalink":"http://s2339956.github.io/IDA_Pro_7.3_Release_v1.0.html","excerpt":"　　IDA Pro 7.3 Release v1.0 (July 2020)","text":"IDA Pro 7.3 Release v1.0 (July 2020) IDA Pro 7.3 Release v1.0 (July 2020)From the team: “Can re-post anywhere provided that the credits below are included and the archive/installer are shared without modifications.” All HexRays vendor watermarks removed from the IDA executables.Decompilers will be released soon after we clear the watermarks from them as well! https://www57.zippyshare.com/v/bEgaZn0p/file.htmlhttps://1fichier.com/?vcgww83zz8g06vwotkd5https://dropapk.to/r1k13hmrodgahttp://www.solidfiles.com/v/Q4xzgWMZ3gaqyhttps://turbobit.net/urgpttamvidv.htmlhttps://tusfiles.com/q1nnjgc3dgul Pass (changed to comply with rules of this board): Board4all The comments above are not mine.Tested briefly and everything seems to work as expected. ###IDA 7.5 Demo+Hex-Rays x64 (Win/Mac/Linux) https://mega.nz/file/LVoFAbaJ#VYFpzoIMYOQSZ2xPTR64nzC-R-e1DG4KUxgEAdlGzZo ###IDA Pro 7.3 (Vendor Watermarks Removed) pass: T3@M-1RA-IDA-PRO https://dropmefiles.com/NFK8H Credits to Team-IRA for cleaning watermarks All HexRays vendor watermarks removed from the IDA executables (to avoid ban). Decompilers will be rele&#65279;ased soon after we clear the watermarks from them as well! You can expect the release of the version 7.5 also soon (after we clear off the watermarks fully)","raw":null,"content":null,"categories":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/categories/macOS/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/tags/macOS/"}]},{"title":"macOS_Time_Machine_時光機首次備份加速法","slug":"macOS_Time_Machine_時光機首次備份加速法","date":"2020-07-08T02:39:38.000Z","updated":"2020-07-08T02:42:09.703Z","comments":true,"path":"macOS_Time_Machine_時光機首次備份加速法.html","link":"","permalink":"http://s2339956.github.io/macOS_Time_Machine_%E6%99%82%E5%85%89%E6%A9%9F%E9%A6%96%E6%AC%A1%E5%82%99%E4%BB%BD%E5%8A%A0%E9%80%9F%E6%B3%95.html","excerpt":"　　如何解除 Time Machine 時光機備份時的限速封印","text":"如何解除 Time Machine 時光機備份時的限速封印 用電腦一段時間的人，都知道備份的重要性。macOS 內建的時光機功能大概是對 Mac 使用者來說最方便的工具之一，既不用額外付費，而且備份於無形，出問題或是重新安裝 macOS 時復原的相容性也高。最近購入一顆 1TB 的外接硬碟，大約 1TB 的首次備份竟然整整花了 48 小時都無法完成！上網找了資訊，原因是 macOS 的時光機備份設有限流，避免備份時影響到正在執行的工作，但是首次備時就悲劇了。解除方式也很簡單，確定程式都關掉，時光機也沒啟動後，打開終端機程式，並輸入下面指令後按 Enter： 1sudo sysctl debug.lowpri_throttle_enabled&#x3D;0 這時你會發現時光機的備份速度變快很多，等首次備份完畢後，重新開機或是再執行下面指令，即可恢復原先有限流的狀態： 1sudo sysctl debug.lowpri_throttle_enabled&#x3D;1 參考資訊：How to speed up your Time Machine backups","raw":null,"content":null,"categories":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/categories/macOS/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/tags/macOS/"}]},{"title":"轉_最差勁的上司常問的五個問題","slug":"轉_最差勁的上司常問的五個問題","date":"2020-05-28T02:39:38.000Z","updated":"2020-05-28T02:49:37.619Z","comments":true,"path":"轉_最差勁的上司常問的五個問題.html","link":"","permalink":"http://s2339956.github.io/%E8%BD%89_%E6%9C%80%E5%B7%AE%E5%8B%81%E7%9A%84%E4%B8%8A%E5%8F%B8%E5%B8%B8%E5%95%8F%E7%9A%84%E4%BA%94%E5%80%8B%E5%95%8F%E9%A1%8C.html","excerpt":"　　在《領導者不能沒有「問題」》里，我提到領導者需要懂得提問。\n通過問題，我們可以發現更多對自己有幫助的信息。\n雖然提問可以帶來很多好處，但是有一個很關鍵的前提――要問對問題。\n要掌握好問對問題的技巧需要時間。\n在還沒練成這項技能前，有沒有哪些問題我們是應該避免的？","text":"在《領導者不能沒有「問題」》里，我提到領導者需要懂得提問。 通過問題，我們可以發現更多對自己有幫助的信息。 雖然提問可以帶來很多好處，但是有一個很關鍵的前提――要問對問題。 要掌握好問對問題的技巧需要時間。 在還沒練成這項技能前，有沒有哪些問題我們是應該避免的？ 01 在《領導者不能沒有「問題」》里，我提到領導者需要懂得提問。 通過問題，我們可以發現更多對自己有幫助的信息。 雖然提問可以帶來很多好處，但是有一個很關鍵的前提――要問對問題。 要掌握好問對問題的技巧需要時間。 在還沒練成這項技能前，有沒有哪些問題我們是應該避免的？ 02 沒水平的領導最愛問的五個問題 「出了什麼問題？」 領導者會發現自己經常提出類似的問題——「出什麼事了」，「存在哪些差錯」，「我們現在的最大威脅是什麼？」很遺憾，80%的管理會議都是以這類問題開場。 如果領導者著重關注問題和弱點，那麼整個組織也會將注意力集中於此，而非聚焦於自己的優勢與機遇。 與其探究哪裡出了差錯和過失，不如提出利用優勢和長處達成目標的積極問題。 例如我們在哪方面做得不錯？ 我們是怎麼成功的？ 理想的結果是什麼？ 我們怎麼做才能更接近目標？ 當我們提出「成長性」問題時，有可能對方開始會不習慣，畢竟大部分的時候他們面對的是「錯誤性」問題。 我們需要給時間對方適應，逐漸培養新常態。 「誰該為此負責？」 這個問題是將注意力聚焦在了尋找「替罪羊」上，但是現實中，很多人是需要對失誤或發生的問題負責任的。 當領導者在追究員工責任時，通常是在為自己的失誤開脫。 其實我們有更好的方法。 通過提出：「我們該如何通過合作彌補弱點？」這樣做可以找到需要改善的薄弱環節，而不是把焦點放在職責錯誤上。 除這之外，當下屬發現我們不是在追責，而是在找解決方案時，他們會更樂意把問題提早說出來。 不然，他們可能為了避開負責任，而什麼都不說。 「為什麼不這麼做？」 這句話聽起來更像是個建議，但若是領導者這麼說，就會變成一個引導性的問題。 這是一種把自己的工作方法強加在他人身上（更糟糕的是，當事情發生後再提出這個問題時，就變成了「你當時為什麼不這麼做？」，這就成了事後怪罪）。 在領導力專家Mary Jo Asmus看來，「每當領導者詢問員工為何不按照自己建議的方式進行工作時，這就是一種隱秘形式的權力控制。」 她強調，如果領導者想雇傭到優秀的員工，那麼他「不應該控制員工如何開展工作」。 最好的方式，是允許員工自己想出辦法。 當然，偶爾我們也可以通過詢問的方式幫助員工開拓思路，但應該是這類詢問，比如「你怎麼看待這件事呢？你對此有什麼想法嗎？」等等。 「我們不是試過這個方法了嗎？」 另一個糟糕的問題還包括，「這個方法過去行不通，你憑什麼相信它現在能成功？」 這類問題有種高高在上的傲慢，甚至有種失敗主義的意味。 當然，這不是說領導者不應質疑員工提出的策略，而是要特別注意詢問的語氣。 這種觀點似乎是說，已經考慮過所有方法了，曾經試過但沒有成功的方法，以後就不該再考慮了。 這種做法忽略了：某些想法過去之所以失敗，不是因為想法本身有錯，而也許是因為執行不力或時機不對。 更好的詢問方式應該是，「如果重新考慮這個方法，這次會有什麼不同？怎麼做才能改變上次的結果？」 「我們怎麼沒做出新產品呢？」 當競爭對手發佈一款新產品時，驚慌失措的老闆們通常會問類似的問題。 事實上，領導者是想對他的下屬們說，「你為什麼沒想出這樣的好點子。快行動起來！」 問題是，這類問題會誤導員工跟風，讓他們認為自己的工作就是用最快的速度去複製別人的新產品。 與其讓團隊去仿造，不如這樣激勵下屬：「為何競爭對手的產品會如此成功？它滿足了哪些需求？我們如何運用自己的特長去滿足消費者的需求？」 03 > 總結 > 身為領導者，掌握提問的技巧是我們必備的技能之一。 除非我們把問題背後的思考說出來，他人只能從我們的問題表面和場景來瞭解我們的意思。 總之，領導者應避免以「像是父母對小孩說話」的方式進行提問，而是要與下屬共同探究問題。 同時，雖然領導者有提問的權力，不要問一個連自己都想不到答案的問題。 作者：蕭理查德 鏈接：https://www.jianshu.com/p/bca8276ddcc2來源：簡書","raw":null,"content":null,"categories":[],"tags":[]},{"title":"macOS 播放影片異常","slug":"macOS_影片異常","date":"2020-04-22T07:39:58.000Z","updated":"2020-04-22T07:45:38.864Z","comments":true,"path":"macOS_影片異常.html","link":"","permalink":"http://s2339956.github.io/macOS_%E5%BD%B1%E7%89%87%E7%95%B0%E5%B8%B8.html","excerpt":"　　macOS 播放影片異常，如：自動超速快轉…等","text":"macOS 播放影片異常，如：自動超速快轉…等 使用command + 空白鍵 開啟 Spotlight，搜尋：活動監視器 在活動監視器中搜尋：audiod，找到 coreaudiod 雙擊，再點選結束，即可恢復正常。","raw":null,"content":null,"categories":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/categories/macOS/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/tags/macOS/"}]},{"title":"macOS 定時任務","slug":"macOS_定時任務","date":"2020-04-06T08:35:35.000Z","updated":"2020-04-06T08:41:34.599Z","comments":true,"path":"macOS_定時任務.html","link":"","permalink":"http://s2339956.github.io/macOS_%E5%AE%9A%E6%99%82%E4%BB%BB%E5%8B%99.html","excerpt":"　　macOS 定時執行 shell 腳本","text":"macOS 定時執行 shell 腳本 執行命令：crontab -e 按 i 編輯文件，添加命令如下： `10 12 * * * sh /home/uploadFile.sh` 10 12 * * * 指每天12點10分開始執行該定時任務 分 时 日 月 周 sh /home/uploadFile.sh 指執行 home目錄下的腳本uploadFile.sh 按ESC返回命令行模式，再按:wq保存並退出，定時任務創建成功。 ps: 關鍵是 sh 比須加上才可以順利執行。","raw":null,"content":null,"categories":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/categories/macOS/"},{"name":"Shell","slug":"macOS/Shell","permalink":"http://s2339956.github.io/categories/macOS/Shell/"}],"tags":[{"name":"macOS","slug":"macOS","permalink":"http://s2339956.github.io/tags/macOS/"},{"name":"Shell","slug":"Shell","permalink":"http://s2339956.github.io/tags/Shell/"}]},{"title":"Android unlock & magisk root","slug":"Android_unlock_magisk_root","date":"2020-02-21T06:16:35.000Z","updated":"2020-03-01T14:53:32.544Z","comments":true,"path":"Android_unlock_magisk_root.html","link":"","permalink":"http://s2339956.github.io/Android_unlock_magisk_root.html","excerpt":"　　android 解鎖與 magisk root","text":"android 解鎖與 magisk root HTC New One (m7) unlock &amp; magisk root準備工具 HTC New One (m7) phone macbook pro (or windows) stable usb cable (穩定的線) adb tool &amp; fastboot tool MagiskManager-v7.5.1.apk &amp; Magisk-v20.3.zip twrp-3.2.1-0-m7.img unlock go to HTCdev login HTCdev Click on “unlock bootloader” Click on “Get Started” Select your device Click on Begin Unlock Bootloader Selecte Yes Click on Proceed to Unlock Instructions, need to tick 接下來僅需照著官方步驟來操作，官方畫面為windows，mac 請自行意會 或者參考一下 雲爸 Magisk root download twrp-3.2.1-0-m7.img。 download Magisk，需下載兩個 apk(Magisk Manager v7.5.1)與zip(Magisk v20.3)。 將 apk 安裝至手機，與zip 上傳至手機上。 將手機與電腦連接，下指令 adb reboot bootloader ，畫面應該如下： 下指令 fastboot flash recovery twrp-3.2.1-0-m7.img 1234➜ android platform-tools/fastboot flash recovery twrp-3.2.1-0-m7.imgSending &#x27;recovery&#x27; (12756 KB) OKAY [ 1.592s]Writing &#x27;recovery&#x27; OKAY [ 0.870s]Finished. Total time: 2.464s 至手機使用音量鍵移動，電源鍵選擇至以下畫面。 再來移動到 RECOVERY 反藍處按電源， 就可以切換到以下twrp-Recovery 畫面。 點擊 Install 。 選擇第三步上傳的檔案。 滑動至右安裝。 完成 ROOT 程序後，選 Reboot system 重開機。 點Do Not Install(不要安裝)後就會重開機，(這裡是問你要不要裝twrp的app)。 接下來就可以享用ROOT的樂趣了。","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"app","slug":"iOS/app","permalink":"http://s2339956.github.io/categories/iOS/app/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"}]},{"title":"修身養性","slug":"修身養性","date":"2020-02-06T03:43:55.000Z","updated":"2020-02-06T06:10:00.748Z","comments":true,"path":"修身養性.html","link":"","permalink":"http://s2339956.github.io/%E4%BF%AE%E8%BA%AB%E9%A4%8A%E6%80%A7.html","excerpt":"　　改善自身","text":"改善自身 清醒時做事，糊塗時讀書，大怒時睡覺，獨處時思考。 話別說太滿，人別熟太快。 人前不應該說的話，背後也別說。 在最憤怒時忍住最傷人對方的那句話。 刻薄嘴欠和幽默是兩回事；口無遮攔和坦率是兩回事；沒有教養和隨性是兩回事；輕重不分和耿直是兩回事。 學會控制自己的情緒，將每種情緒的感受記錄下來，幫助自己認知情緒。 不要吝嗇你的贊美和表達愛意的語言。 別人自嘲可以，但你千萬別附和。 可以嘲笑你的朋友，但不能嘲笑他喜歡的東西。 把「隨便」改成「聽你的」 有錯大大方方的認，一句對不起沒什麼大不了的，切記別找藉口。 請道歉而不是取笑別人開不起玩笑，你以為誰沒有底線只不過還沒到底而已。 不要把負能量帶給身邊的人。 如果沒有十足的把握和必要，就不要輕易說假話。 把「聽明白了嗎」換成「我說明白了嗎」。 如果遇到了傻Ⅹ，不要與他爭論，而且要同意他的一切觀點，把他培養成大傻Ⅹ！ 越是親近的人越要用心對待，一句隨意的話會傷害她。 在拒絕這件事上，越簡單越好，明明是別人需求自己幫忙，解釋半天變成自己虧欠了別人的感覺，幫得上，想幫就幫，幫不上，就拒絕。人際交往，簡單明瞭有時最恰當，懂得拒絕，才可以灑脫不糾結。 不要在公眾場合揭別人的短處，讓別人難堪。 當你往上爬的時候對別人好一點，因為你走下坡路的時候會遇到他們。 逢人只說三分話，未可全拋一片心。 有分寸的信任，有理由的懷疑。 會說話就是讓自己尷尬，而不是讓別人尷尬。 把每一句「我不會」都改成「我可以學」。 學會拒絕，沒人會感激你的善良，他們只會得寸進尺。 「交友不必言盡，言盡則無友」。 不會講話時別瞎說沈默微笑更好。 請不要隨意出賣一個朋友的隱私來取悅另一個不熟的朋友。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"MK5 Golf GTI","slug":"MK5_Golf_GTI","date":"2020-01-31T02:56:11.000Z","updated":"2021-09-15T02:55:04.684Z","comments":true,"path":"MK5_Golf_GTI.html","link":"","permalink":"http://s2339956.github.io/MK5_Golf_GTI.html","excerpt":"　　基礎數據紀錄。","text":"基礎數據紀錄。 MK5 Golf GTI基礎數據車身座位: 5門5人座性能數據: 200hp@5100rpm 28.6kgm@1800rpm變速系統: 6速自手排能量消耗: 平均 11.9km/ltr、市區: 9km/ltr、高速: 14.7km/ltr引擎形式: 渦輪增壓, 直列4缸, DOHC雙凸輪軸, 16氣門壓縮比: 10.3排氣量: 1984cc驅動型式: 前驅 車體數據車長: 4204mm車寬: 1759mm車高: 1485mm車重: 1328kg軸距: 2578mm 底盤採用 PQ35 底盤，「PQ35」中的P代表平台、Q代表發動機橫置、3代表A級轎車，5是指第五代。 因此「PQ35」是指以發動機橫置的 Golf(高爾夫)五代為基礎，能夠拓展研發出各種車型的平台。 防傾桿: 前 23.62.4mm/ 後 21.722mm的規格 變速箱代號：DQ250，濕式6速雙離合器變速箱，簡稱6速DSG 引擎型號： EA113 (皮帶帶動) 內裝座椅可通用於 Golf gti mk6 座椅 總結一台 2005 年的車，或者更老的車，想入門去使用，就必須把車子相關歷史給了解清楚，這樣在後續任何操作上都會更為便利，例如 PQ35 底盤，則可以使用mk6 或等等的底盤零件，進行更換或者升級～ 相關症狀維修轉速忽高忽低 出現轉速忽高忽低，在高速約莫2500轉掉至1500轉，又恢復至2500，渦輪壓力也隨之出現一直在-0.6~-0.4區間飄忽不定，車子會出現前後前後的感覺。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354地址 01: 發動機 標簽:. ZHS\\06F-907-115-AXX.clb零件號 軟件: 1K0 907 115 E 硬件: 1K0 907 115 E組件: 2.0l R4&#x2F;4V TFSI G00 0070 3 個故障碼已找到:000579 - 增压压力控制电磁阀(N75) P0243 - 004 - 故障 - 間歇 故障發生環境要求: 故障狀態: 00100100 故障優先級: 0 故障頻率: 1 故障發生環境要求: 發動機轉速: 2507 &#x2F;min 負荷: 43.5 % 車速: 105.0 km&#x2F;h 溫度: 57.0*C 溫度: 24.0*C 絕對壓力: 1010.0 mbar 電壓: 14.097 V000048 - 氧传感器加热器控制电路（气缸列1（1）传感器1） P0030 - 004 - - 間歇 故障發生環境要求: 故障狀態: 00100100 故障優先級: 0 故障頻率: 1 故障發生環境要求: 發動機轉速: 2507 &#x2F;min 負荷: 43.5 % 車速: 105.0 km&#x2F;h 溫度: 57.0*C 溫度: 24.0*C 絕對壓力: 1010.0 mbar 電壓: 14.097 V000801 - 点火&#x2F;分电器; 发动机转速; 输入电路 P0321 - 008 - 范围&#x2F;性能 故障發生環境要求: 故障狀態: 01101000 故障優先級: 0 故障頻率: 1 故障發生環境要求: 發動機轉速: 0 &#x2F;min 負荷: 0.0 % 車速: 103.0 km&#x2F;h 溫度: 57.0*C 溫度: 24.0*C 絕對壓力: 1010.0 mbar 電壓: 14.097 V 插上VCDS，可以發現點火分電器出現故障，因為只有他沒有轉速與負荷壓力，須對其進行更換即可。 點火分電器: 又名”汽油引擎轉速感應器”、”速度感應器”、”曲軸感應(知)器”約莫 NT$1480~1900/個 水龜節溫器更換時間準則：10年 or 100,000 km 更換症狀：恆溫器不開，關閉和過熱、過冷，加熱不易緩慢地上升，或者水溫一直升高 可直使用 Audi 8p S3 /Golf 6R 原裝 06F121111HKT(06F121111H) 低溫水龜 80c 開， 原裝 Golf gti mk5 06F121111F 要 88c 才開。 備註: 節溫器、水龜 サーモスタッド Thermostat、Coolant regulator 廢油回收 優點: 減少引擎因環保問題，造成積碳 缺點: 費用高，需定期清理回收桶 參考安裝完成效果 電路系統異常 副駕駛 窗戶安鈕失效，已更換過全新按鈕依然無法使用，駕駛座可操控窗戶，證明窗戶升降功能是正常，再來將副駕駛按鈕換至後面門上，也可以正常使用，證明按鈕無損壞，也有更換過殺肉模組，依然失效。 後雨刷 功能失效，僅剩下噴水功能，不會轉動，有殺肉一個雨刷馬達模組，通電正常會轉，但裝上我車上依然只有噴水功能。 正駕駛車門解鎖按鈕失效，但遙控上鎖功能與解鎖正常。 停駛二到三天立即沒電。 經過北投福昌，進行一一排查發現問題1. 是由車門模組引起，連帶引發了問題4. ，問題2. &amp; 3. 是由於電線老化加上長期開關門，造成線路斷掉，重新接上功能立即正常。 ### 零件料號查詢 內文更新於 2021-03-28","raw":null,"content":null,"categories":[{"name":"MK5","slug":"MK5","permalink":"http://s2339956.github.io/categories/MK5/"},{"name":"Golf","slug":"MK5/Golf","permalink":"http://s2339956.github.io/categories/MK5/Golf/"},{"name":"GTI","slug":"MK5/Golf/GTI","permalink":"http://s2339956.github.io/categories/MK5/Golf/GTI/"}],"tags":[{"name":"MK5","slug":"MK5","permalink":"http://s2339956.github.io/tags/MK5/"},{"name":"Golf","slug":"Golf","permalink":"http://s2339956.github.io/tags/Golf/"},{"name":"GTI","slug":"GTI","permalink":"http://s2339956.github.io/tags/GTI/"}]},{"title":"Analysis .a static library","slug":"Analysis_static_library","date":"2019-09-18T04:14:25.000Z","updated":"2019-09-19T10:15:05.504Z","comments":true,"path":"Analysis_static_library.html","link":"","permalink":"http://s2339956.github.io/Analysis_static_library.html","excerpt":"　　分析 .a 靜態庫","text":"分析 .a 靜態庫 分析 .a 靜態庫靜態庫 .a 就是一組 .o 文件的 ar 包，可以用ar -t查看 .a 包含的所有 .o 。 1ar -x somelib_armv7.a 123456789➜ CheckBundleIDSDK ar -t libDGCCheckBundleID_arm64.a__.SYMDEF1.o10.o11.o12.o13.o14.o.... 這是一個經過混淆加密後的 object code: 1234567891011➜ CheckBundleIDSDK cat 1.o���� � �� �__text__TEXT �%�__StaticInit__TEXT�4 �__cstring__TEXT��__objc_methname__TEXT�^�__objc_classn__mod_init_func__DAT�ype__TEXT __cfstring__DATA @� __objc_classlist__DATA� __objc_imageinfo__DATA__objc_const__DATAp��__bss__DATA�__asm__LLVM�� __o__compact_unwind__LD�@� `p�W���O��&#123;������... 報錯在解壓縮 .a 文件時，報錯：is a fat file (use libtool(1) or lipo(1) and ar(1) on it)，原因是 .a 文件包含了多個 cpu 架構，比如arm64, armv7, armv7s等。 解決方法：首先使用如下指令解壓出需要的架構（其中”CheckBundleIDSDK.a”代表需要解壓的 .a 文件) 12345## 解壓縮 64指令集lipo CheckBundleIDSDK.a -thin arm64 -output somelib_arm64.a## 解壓縮 v7s指令集lipo CheckBundleIDSDK.a -thin armv7s -output somelib_armv7s.a 這樣獲得解壓出來的.a（somelib_arm64.a，somelib_armv7s.a）後，再使用如下命令解壓獲得.o文件： 1ar -x somelib_armv7.a -o 後記armv7、armv7s、arm64都是ARM處理器的指令集 i386、x86_64 是Mac處理器的指令集 目前市面上手機幾乎是arm64，故其他可以不用太過關注。 ARM 指令集 設備 arm64 iPhone6s iphone6s plus iPhone6 iPhone6 plus iPhone5S iPad Air iPad mini2(iPad mini with Retina Display) armv7s iPhone5 iPhone5C iPad4(iPad with Retina Display) armv7 iPhone4 iPhone4S iPad2… 等 i386 是針對 intel 通用微處理器32位處理器x86_64 是針對 x86 架構的64位處理器 模擬器32位處理器測試需要 i386 架構，模擬器64位處理器測試需要 x86_64 架構，真機32位處理器需要 armv7, 或者 armv7s 架構，真機64位處理器需要 arm64 架構。","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"app","slug":"iOS/app","permalink":"http://s2339956.github.io/categories/iOS/app/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"}]},{"title":"openSSH Show Chinese","slug":"openSSH_Show_Chinese","date":"2019-09-09T10:15:54.000Z","updated":"2019-09-09T10:17:19.058Z","comments":true,"path":"openSSH_Show_Chinese.html","link":"","permalink":"http://s2339956.github.io/openSSH_Show_Chinese.html","excerpt":"　　openSSH 顯示中文","text":"openSSH 顯示中文 有些 app 的進程名稱可能是中文，還有一些應用創建的目錄可以也會是中文，在 SSH 上使用 debugserver 沒有辦法輸入中文的進程名稱，也沒辦法在 SSH 上操作中文的目錄，google 試了一些方法，不過還是不管用，後來在 Cydia 安裝了一個插件 Local Prefiles in UTF-8 就搞定了，這個插件在 BigBoss 源。使用前使用後 環境 iOS 12.4 (JB: unc0ver) Chimera 越獄 不需要安裝此插件","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"app","slug":"iOS/app","permalink":"http://s2339956.github.io/categories/iOS/app/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"}]},{"title":"iOS lldb + debugserver","slug":"iOS_lldb+debugserver","date":"2019-09-09T03:35:22.000Z","updated":"2019-09-09T07:26:55.639Z","comments":true,"path":"iOS_lldb+debugserver.html","link":"","permalink":"http://s2339956.github.io/iOS_lldb+debugserver.html","excerpt":"　　iOS lldb + debugserver 動態調適","text":"iOS lldb + debugserver 動態調適 前言關於 iOS 動態調適有許多方式，這邊介紹一種比較容易的方法，通過 MacOS 中的 Xcode 自帶的 lldb 與 debugserver 來操作，可以比較便捷的使用，其中也能學習到 lldb 相關的指令，使用於日後正向開發操作上。 在一般開發，使用 Xcode build 至 iphone(實體機) 中，會在手機上創建一個 debugserver，已進行動態調適 (debug)，然而在動態分析上，能通過越獄權限的提升，來自主構建 debugserver，依附至欲分析之app上，達成動態分析與調適。 準備事前準備 macOS 10.14+ Xcode 10.3 iphone iOS 12.4 (JB: unc0ver) openSSH （安裝於 iphone 上） usbmuxd （安裝於 mac 上） iTerm2 （或者其他終端機） 由於 iOS 11 之前需求簽名與添加權限，有些許的難度，但在 iOS 12 之後，不需要再簽名與權限，所以統一使用12.4來操作。 操作 在 iTerm2 上，下指令 iproxy 1111 1111 在 iTerm2 上，開啟第二個分頁(command+T)，SSH 連線至手機， 其操作可以讓mac 與 iphone 在同一個 wifi 下，會更好操作。 1ssh root@192.168.111.1 密碼統一預設為: alpine 在 ssh 分頁中下指令: ps -e，可以找出當前運行中的 app，比如我們要 attach 的進程編號為 693，我們可以輸入如下命令：debugserver *:1111 -a 693 Chimera 越獄: 1/Developer/usr/bin/debugserver localhost:1234 -a 693 unc0ver 越獄: 1debugserver localhost:1234 -a 693 如果要用 debugserver 啓動 app，而不是附加到已經啓動的 app，則使用 debugserver localhost:1111 &lt;app mach-O 路徑&gt;，例如: 1debugserver localhost:1234 /var/containers/Bundle/Application/107F3307-2900-4720-B9BA-0C7792D89DF2/APP_TO_DEBUG.app/APP_TO_DEBUG 在 iTerm2 上，開啟第第三個分頁，下指令: lldb，進入 lldb 界面，使用 process connect 指令連接至手機上。 用 WiFi 連接到 iOS 設備時：process connect connect://localhost:1234 調適其餘奧秘，就留給大家研究嘗試一下吧～ 錯誤error：failed to get reply to handshake packet wget http://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.bz2 tar xjfv usbmuxd-1.0.8.tar.bz2 cd usbmuxd-1.0.8/python-clinet/ python2 tcprelay.py -t 1111:1111 lldb 連接時輸入 process connect connect://localhost:1111 備註 usbmuxd 退出: command + C ssh 退出: exit lldb 退出: exit","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"},{"name":"app","slug":"iOS/app","permalink":"http://s2339956.github.io/categories/iOS/app/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"},{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"}]},{"title":"MacOS 開機自動運行(Boot Automatically)","slug":"mac_Boot_Automatically","date":"2019-08-29T05:36:12.000Z","updated":"2019-08-29T06:10:23.286Z","comments":true,"path":"mac_Boot_Automatically.html","link":"","permalink":"http://s2339956.github.io/mac_Boot_Automatically.html","excerpt":"　　MacOS 開機自動運行(Boot Automatically)","text":"MacOS 開機自動運行(Boot Automatically) 前言Mac 的開機啟動項目一般會在 「系統偏好設定」 ＞「使用者與群組」＞「登入項目」可以找得到。但是有時候也有例外。 因工作需要，有時需要掛上 VPN (Pulse Secure)，但這 APP 實在讓我有點困擾，一重啟電腦，他就自動運行…. 完全不管我是否有需要… MacOS是有分成登入項目(Login Items) 與 啟動項目(Startup Items)兩種。 Startup Items早期版本的 OS X 依賴於兩個資料夾 /Library/StartupItems /System/Library/StartupItems 來保存指定在啟動 Mac 時加載的項目。Apple 現在不鼓勵使用啟動項，但有些程式（主要是較舊的應用程式）仍然使用這種機制。通常你的 /System/Library/StartupItems 資料夾應為空; 但如果它包含您不再使用的內容，則可以將不需要的項目拖到垃圾桶中，以防止下次啟動 Mac 時自動加載。 Launch daemons and agents自從 OS X 10.4 Tiger 以來，Apple 已經為開發人員提供了另一種自動啟動項目的機制：啟動守護進程和代理，由 launchd 進程控制。此方法比登錄項或啟動項提供更大的靈活性，但對用戶而言不太透明。 UNIX 窗簾背後：launchd 不是直接打開應用程式，而是加載特殊格式的 .plist 文檔（XML首選項文件），指定應該啟動什麼以及在什麼情況下啟動。有時這些啟動項目在後台持續運行，有時它們按預定的時間間隔運行，有時它們會根據需要運行 例如，響應某個文件或資料夾中的更改等事件 然後退出。 launchd 使用的 .plist 文件可以佔用五個資料夾中的任何一個，它們的位置決定了項目加載的時間和權限： /Library/LaunchDaemons 和 /System/Library/LaunchDaemons中的項目在 Mac 啟動時加載，並以 root 用戶身份運行。 /Library/LaunchAgents 和 /System/Library/LaunchAgents 中的項在任何用戶登錄時加載，並以該用戶身份運行。 /Users/your-username/Library/LaunchAgents 中的項僅在特定用戶登錄時加載，並以該用戶身份運行。 其中位於 System 資料夾中的 /System/Library/LaunchDaemons 和 /System/Library/LaunchAgents 是作為 OS X 的一部分包含的組件，他們對於保持 MAC 的正常運行非常重要，千萬不要動它們！！！ 對於其它資料夾中的項目，你可以依照需求隨意修改他們。例如禁用它們或更改它們運行的頻率。但在此之前，最好要瞭解它的作用方式。 關閉 Pulse Secure 自動啟動使用終端機(Terminal) 1➜ ~ cd &#x2F;Library&#x2F;LaunchAgents 找到 net.pulsesecure.pulsetray.plist 1➜ LaunchAgents sudo vim net.pulsesecure.pulsetray.plist 修改其中的 Disabled 改為 ture 即可，重開機後就不會再出現哩！ 123&lt;!--Disabled 原本應該為 false--&gt;&lt;key&gt;Disabled&lt;&#x2F;key&gt;&lt;true&#x2F;&gt; 開機自動運行下指令sudo vim /Library/LaunchDaemons/com.go.agent.plist 修改其中的片段，指定為自己的腳本或者程序 123456789101112131415&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-&#x2F;&#x2F;Apple&#x2F;&#x2F;DTD PLIST 1.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.apple.com&#x2F;DTDs&#x2F;PropertyList-1.0.dtd&quot;&gt;&lt;plist version&#x3D;&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;Label&lt;&#x2F;key&gt; &lt;string&gt;com.go.agent&lt;&#x2F;string&gt; &lt;key&gt;ProgramArguments&lt;&#x2F;key&gt; &lt;array&gt; &lt;string&gt;python&lt;&#x2F;string&gt; &lt;string&gt;&#x2F;Users&#x2F;leedani&#x2F;Downloads&#x2F;goagent&#x2F;local&#x2F;proxy.py（修改為存放goagent proxy.py的路徑）&lt;&#x2F;string&gt; &lt;&#x2F;array&gt; &lt;key&gt;RunAtLoad&lt;&#x2F;key&gt; &lt;true&#x2F;&gt;&lt;&#x2F;dict&gt;&lt;&#x2F;plist&gt; 下指令launchctl load /Library/LaunchDaemons/com.go.agent.plist","raw":null,"content":null,"categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/categories/MacOS/"},{"name":"app","slug":"MacOS/app","permalink":"http://s2339956.github.io/categories/MacOS/app/"}],"tags":[{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"},{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/tags/MacOS/"}]},{"title":"apple api get app versions","slug":"apple_api_get_app_versions","date":"2019-08-26T09:51:32.000Z","updated":"2019-08-26T09:58:25.432Z","comments":true,"path":"apple_api_get_app_versions.html","link":"","permalink":"http://s2339956.github.io/apple_api_get_app_versions.html","excerpt":"　　通過 apple api 取得舊版 app ID","text":"通過 apple api 取得舊版 app ID apple api get app versionsGET:&quot;https://api.unlimapps.com/v1/apple_apps/&#123;ID&#125;/versions&quot;ID: 請填入app編號Response: 1234567891011121314151617181920212223242526[ &#123; &quot;id&quot;: &quot;87945b4e-24de-4677-81c8-6f980839c8e5&quot;, &quot;apple_app_id&quot;: &quot;84389e6e-852b-450b-be5b-5ab92ddcd667&quot;, &quot;bundle_version&quot;: &quot;10.49&quot;, &quot;external_identifier&quot;: &quot;815198513&quot;, &quot;created_at&quot;: &quot;2016-01-06T04:26:55.666Z&quot;, &quot;updated_at&quot;: &quot;2016-01-06T04:26:55.666Z&quot; &#125;, &#123; &quot;id&quot;: &quot;3bf5ea73-0cd0-45ef-92c3-3a89b9c3543c&quot;, &quot;apple_app_id&quot;: &quot;84389e6e-852b-450b-be5b-5ab92ddcd667&quot;, &quot;bundle_version&quot;: &quot;10.50&quot;, &quot;external_identifier&quot;: &quot;815713258&quot;, &quot;created_at&quot;: &quot;2016-01-11T14:51:41.430Z&quot;, &quot;updated_at&quot;: &quot;2017-09-28T10:11:10.467Z&quot; &#125;, &#123; &quot;id&quot;: &quot;707e50be-82d0-480e-9da6-e9c3b4f9a7fd&quot;, &quot;apple_app_id&quot;: &quot;84389e6e-852b-450b-be5b-5ab92ddcd667&quot;, &quot;bundle_version&quot;: &quot;10.38&quot;, &quot;external_identifier&quot;: &quot;813553231&quot;, &quot;created_at&quot;: &quot;2016-01-17T09:21:09.179Z&quot;, &quot;updated_at&quot;: &quot;2016-01-17T09:21:09.179Z&quot; &#125;, ...... 解析: 123456789101112&quot;id&quot;: &quot;707e50be-82d0-480e-9da6-e9c3b4f9a7fd&quot;,## &quot;apple_app_id&quot;: &quot;84389e6e-852b-450b-be5b-5ab92ddcd667&quot;,## &quot;bundle_version&quot;: &quot;10.38&quot;,## &quot;external_identifier&quot;: &quot;813553231&quot;,## 此為下載舊版app的id&quot;created_at&quot;: &quot;2016-01-17T09:21:09.179Z&quot;,## &quot;updated_at&quot;: &quot;2016-01-17T09:21:09.179Z&quot;## app id 取得方式如圖所示，直接在apple官方網中搜索，取得對應 ID","raw":null,"content":null,"categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/categories/MacOS/"},{"name":"app","slug":"MacOS/app","permalink":"http://s2339956.github.io/categories/MacOS/app/"}],"tags":[{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"},{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/tags/MacOS/"}]},{"title":"無限試用 Navicat Premium","slug":"無限試用Navicat Premium","date":"2019-08-11T09:30:22.000Z","updated":"2019-08-14T05:29:54.540Z","comments":true,"path":"無限試用Navicat Premium.html","link":"","permalink":"http://s2339956.github.io/%E7%84%A1%E9%99%90%E8%A9%A6%E7%94%A8Navicat%20Premium.html","excerpt":"　　逆向攻破，無限試用。","text":"逆向攻破，無限試用。 前言經過一段時間後，試用期已到期，無法再繼續享受 Navicat Premium，所帶來的方便，如下圖: 決定來研究一下，該app相關的內碼，在此聲明，該文章純屬學習研究，請勿用於其他途徑。 過程 找出二進制文件(mach-O、unix執行檔)，/Applications/Navicat Premium.app/Contents/MacOS/Navicat Premium 使用 Hopper Disassembler v4 Standard Edition (4.5.13)，來對二進制文件反編譯 搜索字串http://www.navicat.com/cht/store，找到 1234567891011## 找到使用者0000000102d5bf5b db &quot;http://www.navicat.com/cht/store&quot;, 0 ; DATA XREF=cfstring_http___www_navicat_com_cht_store## 相關地址0000000103c2b600 dq 0x0000000104750310, 0x00000000000007c8, 0x0000000102d5bf5b, 0x0000000000000020 ; &quot;http://www.navicat.com/cht/store&quot;, DATA XREF=qword_103f773b8## 使用者0000000103f773b8 dq 0x0000000103c2b600 ; @&quot;http://www.navicat.com/cht/store&quot;, DATA XREF=+[Registration ApplicationChecking:isLaunch:]+481, +[Registration ApplicationChecking:isLaunch:]+899, +[Registration ApplicationChecking:isLaunch:]+5518, +[Registration ApplicationChecking:isLaunch:]+5758, +[Registration ApplicationChecking:isLaunch:]+6039, +[Registration ApplicationChecking:isLaunch:]+9206, -[Registration BuyNow:]+52## ↑ [Registration ApplicationChecking:isLaunch:]，如名得知，這可能是一個檢查方法 查看一下方法的匯編程式碼(assembly language)， 1234mov ebx, eaxcmp ebx, 0xffffffffje loc_100325e47 其關鍵指令如上，賦值給ebx，再進行判斷exb如果等於1，就跳轉至地址loc_100325e47，然而如果不等於則跳轉至loc_100325e47，loc_100325e47也是通過檢測後執行的方法。 修改指令 1234mov ebx, 0x0je loc_100325e47 直接跳過判斷指令，來到最終目的。 儲存並輸出 拖回原位置，並取代 總結此app對於購買流程的安全保護，幾乎可以說是零，對於一般攻擊者而言，很容易就可以完成了，另外也能使用插件的方式去hook相關方法再去繞過檢測，但如果熟悉匯編程式碼(assembly language)，在操作繞過方面會比較簡易且快速，另外呼籲大家務必支持正版，杜絕盜版。","raw":null,"content":null,"categories":[{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/categories/MacOS/"},{"name":"app","slug":"MacOS/app","permalink":"http://s2339956.github.io/categories/MacOS/app/"}],"tags":[{"name":"app","slug":"app","permalink":"http://s2339956.github.io/tags/app/"},{"name":"MacOS","slug":"MacOS","permalink":"http://s2339956.github.io/tags/MacOS/"}]},{"title":"iOS 密碼學(RSA)","slug":"iOS_Cryptography(RSA)","date":"2019-04-30T06:49:11.000Z","updated":"2019-04-30T07:33:00.000Z","comments":true,"path":"iOS_Cryptography(RSA).html","link":"","permalink":"http://s2339956.github.io/iOS_Cryptography(RSA).html","excerpt":"　　iOS 密碼學(RSA)，粗略介紹。\n　　","text":"iOS 密碼學(RSA)，粗略介紹。 導引我將從以下四點來講述密碼學相關內容： 什麼是密碼學 RSA數學原理 RSA終端命令 總結 什麼是密碼學密碼學的歷史大致可以追溯到兩千年前，相傳古羅馬名將凱撒大帝為了防止敵方截獲情報，用密碼傳送情報。凱撒的做法很簡單，就是對二十幾個羅馬字母建立一張對應表。這樣，如果不知道密碼本，即使截獲一段信息也看不懂。 從凱撒大帝時代到上世紀70年代這段很長的時間裡，密碼學的發展非常的緩慢，因為設計者基本上靠經驗。沒有運用數學原理。在1976年以前，所有的加密方法都是同一種模式：加密、解密使用同一種算法。在交互數據的時候，彼此通信的雙方就必須將規則告訴對方，否則沒法解密。那麼加密和解密的規則（簡稱密鑰），它保護就顯得尤其重要。傳遞密鑰就成為了最大的隱患。這種加密方式被成為對稱密鑰演算法（英語：Symmetric-key algorithm）。 1976年，兩位美國計算機學家 迪菲（W.Diffie）、赫爾曼（ M.Hellman ） 提出了一種嶄新構思，可以在不直接傳遞密鑰的情況下，完成密鑰交換。這被稱為”迪菲赫爾曼密鑰交換”算法。開創了密碼學研究的新方向。 1977年三位麻省理工學院的數學家羅納德·李維斯特（Ron Rivest）、阿迪·薩莫爾（Adi Shamir）和倫納德·阿德曼（Leonard Adleman）一起設計了一種算法，可以實現非對稱加密。這個算法用他們三個人的名字命名，叫做RSA算法。也就是說「迪菲-赫爾曼密鑰交換(英語：Diffie–Hellman key exchange，縮寫為D-H)」在密碼學歷史的車輪中成為了一個轉折點。 RSA數學原理我們先把所有需要用到的公式定理列出來： 取模運算 歐拉函數φ 歐拉定理，費馬小定理 模反元素 迪菲赫爾曼密鑰交換 1. 取模運算取模運算（“Modulo Operation”）和取餘運算（“Complementation ”）兩個概念有重疊的部分但又不完全一致。主要的區別在於對負整數進行除法運算時操作不同。 在這列出各種負數情況的例子供大家理解：7 mod 4 = 3（商 = 1 或 2，1&lt;2，取商=1）-7 mod 4 = 1（商 = -1 或 -2，-2&lt;-1，取商=-2）7 mod -4 = -1（商 = -1或-2，-2&lt;-1，取商=-2）-7 mod -4 = -3（商 = 1或2，1&lt;2，取商=1）函數值符號規律(餘數的符號) mod(負,正)=正 mod(正,負)=負 結論：兩個整數求餘時，其值的符號為除數的符號。 2. 歐拉函數φ可以簡單理解為：如果n可以分解為兩個互質(不一定是兩個質數)的數之積A和B，那麼：φ(n) = φ(A) * φ(B) 如果 A和B 又同時為質數，那麼： φ(n) = (A-1) * (B-1) 3. 歐拉定理，費馬小定理首先這裡說一下，定制之所以是定理是被人證明過的，如何證明的不管，當然你也可以增加去證明下，反正我不管（……&amp;%￥%……&amp;%&amp;……&amp;% ），哈哈 如果m、n為正整數，且m、n互質，那麼： ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/2e818f3f88d3e71e569f171dd86f31e1903fdc55) 如果n為質數，那麼： ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/5b71e80b05f598bfd9ac9618c87a94323e41e688) 公式轉換： ![](https://upload-images.jianshu.io/upload_images/1122613-3d34ffb888fe6ebe.png) 4. 模反元素如果兩個正整數e和x互質，那麼一定可以找到整數d，使得 e*d-1 被x整除。那麼d就是e對於x的”模反元素”。 ![](https://upload-images.jianshu.io/upload_images/1122613-ce908da3ee97ec69.png) 5. 迪菲赫爾曼密鑰交換 如上圖：客戶端持有一個隨機數13 ，服務端持有隨機數15，再選一對特殊的數，3是17的原根。兩端交換的都是密文，就算中間被劫持，也不知道最後需要的傳輸的內容是10 那麼這個10就是最後真正的密鑰。 證明過程： 1234567&#x3D;&#x3D;&gt; 3^(13 * 15) mod 17 &#x3D; 3^(13 * 15) mod 17 根據模冪運算 ((m^e mod n)^d) mod n &#x3D; m^(e*d) mod n&#x3D;&#x3D;&gt; (3^13 mod 17)^13 mod 17 &#x3D; (3^15 mod 17)^15 mod 17由於 3^13 mod 17 &#x3D; 12 3^15 mod 17 &#x3D; 6&#x3D;&#x3D;&gt; 6^13 mod 17 &#x3D; 12^15 mod 17 &#x3D; 10 設 1m&#x3D;3, e&#x3D;13, d&#x3D;15, n&#x3D;17, C&#x3D;12 那麼 12m^e mod n &#x3D; cc^d mod n &#x3D; (m^e mod n)^d mod n &#x3D; m^(e*d) mod n 又由於上面模反元素，最後得出 1m^(e*d) mod n &#x3D; m 所以得出最終結論： 12m^e mod n &#x3D; cc^d mod n &#x3D; m 這個公式也就是我們最後的RSA加密公式！ ！ ！其中： 12345公鑰： n和e私鑰： n和d明文: m密文: cd是e對於φ(n)的&quot;模反元素&quot;。 >補充： >1. n會非常大，長度一般為1024個二進制位。 >（目前人類已經分解的最大整數，232個十進制位，768個二進制位） >2. 由於需要求出φ(n)，所以根據歐函數特點，最簡單的方式n 由兩個質數相乘得到: 質數：p1、p2 Φ(n) = (p1 -1) * (p2 - 1) >3. 最終由φ(n)得到e 和 d 。 總共生成6個數字：p1、p2、n、φ(n)、e、d 關於RSA的安全： 除了公鑰用到了n和e 其餘的4個數字是不公開的。 目前破解RSA得到d的方式如下： 要想求出私鑰 d 。由於ed = φ(n)k + 1。要知道e和φ(n); e是知道的，但是要得到 φ(n)，必須知道p1 和 p2。 由於 n=p1*p2。只有將n因數分解才能算出。 RSA終端命令 由於Mac系統內的 OpenSSL(開源加密庫)，所以我們可以直接在iTerm上使用命令來玩RSA. OpenSSL中RSA算法常用指令主要有三個： 命令 說明 genrsa 生成並且輸出一串RSA私鑰 rsautl 使用RSA密鑰進行加密、解密、簽名和驗證等運算 rsa 處理RSA密鑰的格式轉換等問題 1. 生成RSA私鑰，密鑰長度為1024bit12&#x2F;&#x2F; 生成RSA私鑰，密鑰長度為1024bitopenssl genrsa -out private.pem 1024 12345➜ Downloads openssl genrsa -out private.pem 1024Generating RSA private key, 1024 bit long modulus........+++++................................+++++e is 65537 (0x10001) 2. 從私鑰中提取公鑰12&#x2F;&#x2F; 從私鑰中提取公鑰openssl rsa -in private.pem -pubout -out public.pem 12➜ Downloads openssl rsa -in private.pem -pubout -out public.pemwriting RSA key 3. 將私鑰轉換成為明文12&#x2F;&#x2F; 將私鑰轉換成為明文openssl rsa -in private.pem -text -out private.txt cat private.txt 123456➜ Downloads openssl rsa -in private.pem -text -out private.txtcat private.txtwriting RSA keyPrivate-Key: (1024 bit)modulus: 00:c6:46:ac:0e:4f:3b:01:2f:15:f3:94:23:50:32: 4. 通過公鑰加密數據，私鑰解密數據123456789101112&#x2F;&#x2F; 新建一個文件，在文件中隨意輸入內容，比如輸入字符串”Hello“vim message.txt&#x2F;&#x2F; 查看文件cat message.txt&#x2F;&#x2F; 通過公鑰進行加密openssl rsautl -encrypt -in message.txt -inkey public.pem -pubin -out enc.txt&#x2F;&#x2F; 通過私鑰進行解密openssl rsautl -decrypt -in enc.txt -inkey private.pem -out dec.txt&#x2F;&#x2F; 查看加密後的文件cat enc.txt&#x2F;&#x2F; 查看解密後的文件cat dec.txt 5. 通過私鑰加密數據，公鑰解密數據12345&#x2F;&#x2F; 私鑰加密openssl rsautl -sign -in message.txt -inkey private.pem -out enc_2.txt&#x2F;&#x2F; 公鑰加密openssl rsautl -verify -in enc_2.txt -inkey public.pem -pubin -out dec_2.txt ## 總結 由於RSA加密解密用的不是一套數據，所以其保證了安全性。 由於私鑰過大，所以效率較低 如果有一天量子計算機被普及(計算速度極快)，那麼1024位已經不足以讓RSA安全。","raw":null,"content":null,"categories":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/categories/iOS/"}],"tags":[]},{"title":"Xcode10 配置 Logos 語法高亮","slug":"Xcode10LogosSupports","date":"2019-04-24T06:34:51.000Z","updated":"2019-04-24T06:53:46.000Z","comments":true,"path":"Xcode10LogosSupports.html","link":"","permalink":"http://s2339956.github.io/Xcode10LogosSupports.html","excerpt":"　　Xcode10 配置 Logos 語法高亮、模糊輸入\n　　","text":"Xcode10 配置 Logos 語法高亮、模糊輸入 安裝 備份 /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources 下載連結，或者 clone 到電腦上git clone https://github.com/s2339956/Logos-Xcode 到剛下載的目錄下的src目錄(Logos-Xcode/src) 確保已經關閉結束運行 Xcode 使用python3 執行 xclangspec_generator.py 腳本 執行 chmod +x install.sh，使 install.sh 預備執行權限 執行 sudo ./install.sh 開始享用 使用Select Editor -&gt; Syntax Coloring -&gt; Logos on the menu.","raw":null,"content":null,"categories":[{"name":"Xcode","slug":"Xcode","permalink":"http://s2339956.github.io/categories/Xcode/"},{"name":"Logos","slug":"Xcode/Logos","permalink":"http://s2339956.github.io/categories/Xcode/Logos/"}],"tags":[]},{"title":"遊戲外掛開發原理","slug":"Game_plug-in development_principle","date":"2019-04-23T06:30:51.000Z","updated":"2019-04-23T06:50:47.000Z","comments":true,"path":"Game_plug-in development_principle.html","link":"","permalink":"http://s2339956.github.io/Game_plug-in%20development_principle.html","excerpt":"　　簡單說明一下主流外掛種類與開發步驟\n　　","text":"簡單說明一下主流外掛種類與開發步驟 遊戲外掛開發原理 外掛現在大體上來講分為三種，分別是模擬按鍵，WPE封包和內存(記憶體)掛。比如模擬鍵盤的、滑鼠的，這種就叫做按鍵模擬，也叫腳本(按鍵)精靈；還有修改數據包(封包)的，這種就叫做WPE封包外掛，這種外掛相對而言比較穩定，但是對於技術要求難度也比較高，因為修改WPE封包，你需要知道與了解加密解密算法等等一系列的知識；還有最後一種就是修改本地記憶體的，這種相對而言比較常見，市場上面比較常見的也是這種遊戲外掛，相對而言技術要求也不是太高，資料也比較齊全，比較大眾；但好像沒有修改服務器內存的哦，呵呵。其實修改服務器也是有辦法的，只是技術太高一般人沒有辦法操作而已。 其實，製作內存(記憶體)掛也不是很難，步驟就這麼幾步。第一步，找遊戲數據內存(記憶體)地址，偏移地址；第二步，修改內存(記憶體)地址的值，達到外掛的目的；第三步，使用熟悉的語言寫出一支程式，使得外掛方便於攜帶傳輸，同時也方便於下次玩遊戲直接使用。其實第三步主要是方便使用，方便販賣等等，很多時候對於一個高手而言，根本不需要寫出來，記錄下內存(記憶體)地址，偏移地址以後，下次上游戲直接工具裡面修改就是了。但是如果經常玩某個遊戲，可以寫出來，用不著每次玩遊戲都去修改。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"過去 iOS APP 安全檢測心得","slug":"iOS_APP_Safety_Detection_Experience","date":"2019-03-12T06:44:31.000Z","updated":"2019-03-12T06:47:21.000Z","comments":true,"path":"iOS_APP_Safety_Detection_Experience.html","link":"","permalink":"http://s2339956.github.io/iOS_APP_Safety_Detection_Experience.html","excerpt":"　　iOS APP 安全檢測一些心得總結","text":"iOS APP 安全檢測一些心得總結 為什麼要進行 iOS APP 檢測？在2015年9月份時在 AppStore 很多 APP 被注入第三方惡意代碼，針對這個問題，盤古實驗室緊急開發了病毒檢測工具，並檢測到大量的受感染的樣本。這個事件大家比較熟悉，我不多做描述，有興趣可以去自己搜尋一下。我們通過這個問題考慮為什麼進行 iOS APP 檢測？使用 iOS 的大部分用戶或者在傳統媒體只做app開發的人認為，使用 iphone 從 AppStore 下載一個應用是絕對安全的。事實上並不是這樣的，除了 ZipperDown 之外還有一些問題沒有被發出來。有些APP還會收集大家的隱私和通訊錄等等，所以 AppStore 下載的應用並不完全是安全的。大部分 iOS 開發人員，認為安全相關的內容與自己無關，依賴卻並不是完全了解蘋果的安全機制，這是在開發中很常見的，因為趕進度或者產品經理奇怪的需求，開發人員會有意無意破壞蘋果提供的安全機制，導致他開發出來的 APP 並不安全。iOS 平台檢測更依賴於經驗，Android 有很多自動化檢測工具，檢測 Android APP 時大家會使用自動化使用工具做出一個報表，然後看看有什麼需要人工去分析的地方再去深入分析。 iOS 不一樣，市面上用的自動化檢測工具非常簡單，檢測出來的報告沒什麼意義。做 iOS 的 APP 檢測時需要做人工檢測，更多工作內容放在人工，人工檢測非常依賴經驗。iOS平台檢測的工具有很多，每個都有自己特定的作用。非常理解檢測基本結構，首先，拿到一個APP需要先做靜態分析，之後根據靜態分析出來的結果做一些簡單的動態分析，動態分析主要就是抓包，看看有沒有什麼危險的包，這是明顯一眼可以看出來的問題。其次，根據檢測出來的結果和靜態分析的代碼，看看比較容易出問題的代碼是否用到。大家去市面找到iOS 教學或書籍，可以詳細的大家告訴有哪些靜態工具、動態工具。可是它們沒有被整合在一起、很零散，做 iOS 立項或者檢測時需要大量時間熟悉我們用的工具。這裡是給大家總結一下我們做這麼長時間 iOS APP 檢測的常見問題： 不安全的隨機函數。 APP 切換到後台暴露敏感信息，比如你的手機 APP 在跟別人聊天，你按home會切到後台，它有一個截屏。當然，如果不是越獄的手機，基本是沒有風險的。 存在本地數據庫的 SQL 注入。 自動使用第三方鍵盤輸入敏感訊息，第三方鍵盤上傳東西的話，可能敏感訊息會被上傳到伺服器。 沒有正確的使用SSL。 未能正確的處理所有的 urlscheme 接口沒有詳細過濾。 其他問題。這些都是常見的小問題，一般這種問題在開發者或者在廠商看來都不是什麼大問題。 接下來看看一般廠商比較重視的問題： 1、短信驗證未作限制。登入或註冊時未對獲取短信驗證碼的次數作限製或限制不夠嚴謹。這個問題的檢測方法是通過抓包，去請求驗證碼的請求包，看看這個驗證碼會不會重新放回來。做得最差的是沒有任何前置，可以向伺服器請求，伺服器可能會發幾十條幾百回，有的伺服器會做一天十條或者一天二十條，或者一段時間內頻繁發，它會把你阻塞，過一段時間再讓你發。開發者在做檢測這時一定要要嚴謹，我遇到一個做了檢測，他根據 cookie 和一堆亂七八糟的ID做檢測，我們通過抓包之後把所有的ID都刪了，它又可以通過了，它的伺服器代碼分支裡沒有考慮到所有的詞都沒有情況下，所以沒有做限制。最主要的問題是直接的經濟損失，一條短信幾分錢也是錢，一天可以發很多條。 2、非 HTTPS 網絡請求。在訪問資源沒有通過 HTTPS 做網絡請求，檢測方法是打開 APP 通過撞戶程式(與狀庫原理相同)去看是不是有不是 http 的請求。這個檢測方法也非常簡單，就打開 APP 通過帳號，去看是否有不是 http 的請求是不是在獲取敏感訊息，比如拉出資源包或者 txt 腳本。我見過最誇張的是整個 APP 裡面全部是 http 的網站，它裡面包括支付、登入，所有東西全在 http 裡，這是非常容易損失的。這裡多提一句，我們檢測國外 APP 時，在美國的 AppStore 上也檢測了很多APP，這個問題從來沒被發現過，但國內的 APP 中這個問題一抓一大把，所以國內在 https 的使用上需要加強。傳一些大的文件， CDN 太貴，可以通過 https 傳一個哈希，變通的方法，因為這個確實影響很大，在惡意的網路環境中資源文件會被替換，主要攻擊就是從這裡來做的，這是主要的入口。 3、敏感訊息儲存於本地。敏感的訊息例如帳號、密碼或者加密使用的密鑰保存在本地。這個檢測方法是通過靜態分析，看看有沒有敏感的。它的影響是不越獄的手機是不影響的，但是你把用戶的信息存在本地，如果手機丟了或者別人拿到你手機幫你越獄了，或者你的手機被別人越獄了，我就知道你 APP 裡面存在的敏感信息是什麼，這是其一。其二，密鑰會保存在本地，APP 廠商的用戶有幾十萬，它的密鑰都是這個，我自己越獄裝一個 APP，把這個密鑰提取出來，在非越獄的手機上通過 http 傳輸的數據是通過密鑰加密的，同樣又可以回到內容去替換它的資源。 4、伺服器信任客戶端的請求。這個問題比較常見，就是伺服器客戶端請求中的數，最常見的就是在做一款遊戲時，客戶端發過來的請求伺服器沒有做驗證，伺服器直接信任客戶端。 《吃雞》這種遊戲是沒有辦法的，但同時一些卡牌手遊也會有這種問題，比如遊戲功能完全信賴客戶端，客戶端告訴它\"我的伺服器是完全信任的\"，這樣導致廠商的損失。我遇到過檢測國外的 APP，它把信任本地保存的圖片同步到伺服器上，而這張圖片是做臉部識別的，只要我拿到別人的手機，把它越獄，這個 APP 再次打開時會把我修改過的照片上傳到伺服器。數據庫裡的照片就被換成了我的照片，我拿那個 APP 照我的臉就可以登入別人的帳號，這個影響比較大。這個排查起來比較簡單，主要是通過原始碼的開發軟體，檢查一下客戶端發出來的請求，伺服器是不是完全默認。這個問題雖然很簡單，但影響很大。這些都是傳統的檢測方法和得到的結果。 總結和思考總結和思考，可看見實際情況與開發人員的猜測存在一定的出入，結合我自身的開發經驗，思考我自己開發的項目中存在過的安全問題，發現做安全和做開發時，開發人員不知道安全人員在想什麼。這叫”達克效應”，是一種認知的偏差，在某一方面的能力欠缺時錯誤的認為自己比真實情況更加優秀，認為只要做了 zip 加密就可以保護 APP 安全了。但在 ZipperDown 和論壇中反映了，hotpatch 相關程式碼的處理是完全沒有問題的，但是其他開發人員在 APP 下載一堆zip包且未使用 https 導致了最後的問題，對軟件開發和安全攻防中客觀存在的情況，是一個比較貼切的解釋和總結。話說回來，開發人員的主要工作是開發軟體，業務壓力很大，精力有限。我作為開發人員經驗讓我明白在安全問題上犯下錯誤是難免的，所以開發人員可以多上論壇了解安全知識，減少程式碼及設計上的安全問題。一些非常隱蔽的小問題，開發人員覺得不是問題的，但其是可以被利用的，這就需要專業安全團隊幫助開發人員去檢測了。","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"免越獄 ShootMoon.app 逆向","slug":"Non-Jailbreak_Shoot_The Moon_Reverse","date":"2019-03-07T02:59:56.000Z","updated":"2019-03-07T09:20:33.000Z","comments":true,"path":"Non-Jailbreak_Shoot_The Moon_Reverse.html","link":"","permalink":"http://s2339956.github.io/Non-Jailbreak_Shoot_The%20Moon_Reverse.html","excerpt":"　　免越獄 ShootMoon.app 逆向、修改","text":"免越獄 ShootMoon.app 逆向、修改 輸出 IPA![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/OutputIPA.png) 使用Hopper Disassembler啟動Hopper Disassembler，選單中選擇File-&gt;Read Executable to Disassembler…，或者按下快捷鍵Command+Shift+O，彈出的對話框中選擇 shootthemoon 文件，再點擊OK。緊接著會彈出如下圖所示的對話框，保持默認選項，點擊OK。![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/Hopper_Disassmbler_.png) 分析與實現找到 GamePlay Class，發現他有一個方法是 updateScore，我們先對這方法 hook，嘗試看看![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/CaptainHook_ UpdateScore.png)這邊我們使用 CaptainHook 來撰寫Hook方法，接著回到遊戲體驗一下，發現這樣的方法，只要射擊到月亮，就直接結束遊戲了…![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/Hopper_Disassmbler_1.png)看一下 method updateScore 反編譯結果，發現他呼叫了一個 ohHoHo 方法，也是在同一個 Class 底下，這邊經驗告述我們，傳進來的參數 arg2 != 0，就進到這個 if 中！ 八九不離十，這應該是最終更新分數的方法![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/Hopper_Disassmbler_2.png)在查看一下這方法，對他進行 hook 發現確實跟我們想的一樣 ![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/CaptainHook_ Ohohoh.png) 最終我們完成修改，為了不讓遊戲體驗變得太糟，我們讓原本分數乘10，並調用加時間，能避免一次就過關了… ![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/IMG_0030.PNG) ![](source/images/Non-Jailbreak_Shoot_The Moon_Reverse/Shoot_The Moon.gif) 總結這個逆向工程，主要是為了練習 CaptainHook 的使用與寫法，logos 寫法在 Xcode 中無法模糊輸入，沒記下所有的code確實會很礙事…","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"免越獄 iOS12 Badge Color Changer","slug":"Non-Jailbreak_iOS12_Badge_Color_Changer","date":"2019-03-05T06:38:55.000Z","updated":"2019-03-05T06:49:39.000Z","comments":true,"path":"Non-Jailbreak_iOS12_Badge_Color_Changer.html","link":"","permalink":"http://s2339956.github.io/Non-Jailbreak_iOS12_Badge_Color_Changer.html","excerpt":"　　iOS 12 免越獄 修改桌面app Badge 顏色","text":"iOS 12 免越獄 修改桌面app Badge 顏色 twitter 原文reddit 原文 主要利用 iOS 12～iOS 12.1.2 漏洞，提權，然後tfp0 patch 再去修改 “/private/var/mobile/Library/Caches/MappedImageCache/Persistent/SBIconBadgeView.BadgeBackground.cpbitmap” 就能達成修改顏色了 下載 ipaGet color codes","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"Python 開發必備神器之一：virtualenv","slug":"Python 開發必備神器之一：virtualenv","date":"2018-06-05T03:04:26.000Z","updated":"2018-06-05T03:43:05.000Z","comments":true,"path":"Python 開發必備神器之一：virtualenv.html","link":"","permalink":"http://s2339956.github.io/Python%20%E9%96%8B%E7%99%BC%E5%BF%85%E5%82%99%E7%A5%9E%E5%99%A8%E4%B9%8B%E4%B8%80%EF%BC%9Avirtualenv.html","excerpt":"　　並獨立出 Python 環境。可使每個項目環境與其他項目獨立開來，保持環境的干淨，解決包衝突問題。","text":"並獨立出 Python 環境。可使每個項目環境與其他項目獨立開來，保持環境的干淨，解決包衝突問題。 Python的第三方包成千上萬，在一個Python環境下開發時間越久，安裝依賴越多，就越容易出現依賴包衝突的問題。為了解決這個問題，開發者們開發出了 virtualenv，可以搭建虛擬 並獨立的Python環境。這樣就可以使每個項目環境與其他項目獨立開來，保持環境的干淨，解決包衝突問題。 安裝 virtualenvvirtualenv 是一個第三方包，是管理虛擬環境的常用方法之一。此外，Python 3 中還自帶了虛擬環境管理包。 我們可以用的 easy_install 或者 pip 安裝。 1$ pip install virtualenv 基本用法創建項目的虛擬環境12$ cd my_project_folder$ virtualenv venv # venv 可替換為别的虛擬環境名稱 執行後，在本地會生成一個與虛擬環境同名的文件夾，包含 Python 可執行文件和 pip 庫的拷貝，可用於安裝其他包。 但是默認情況下，虛擬環境中不會包含也無法使用系統環境的global site-packages。比如係統環境里安裝了請求requests，在虛擬環境裡import requests會提示 ImportError。如果想使用系統環境的第三方軟件包，可以在創建虛擬環境時使用參數–system-site-packages。 1$ virtualenv --system-site-packages venv 另外，你還可以自己指定虛擬環境所使用的 Python 版本，但前提是系统中已經安裝了該版本： 1$ virtualenv -p /usr/bin/python2.7 venv 使用虛擬環境進入虛擬環境目錄，啟動虛擬環境。 123$ cd venv$ source bin/activate # Windows 系統下運行 Scripts\\$ python -V 如果未對命令行進行個性化，此時命令行前面應該會多出一個括號，括號裡為虛擬環境的名稱。啟動虛擬環境後安裝的所有模塊都會安裝到該虛擬環境目錄裡。 退出虛擬環境： 1$ deactivate 如果項目開發完成後想刪除虛擬環境，直接刪除虛擬環境目錄即可。 使用 virtualenvwrapper上述 virtualenv 的操作其實已經夠簡單了，但對於開發者來說還是不夠簡便，所以便有了 virtualenvwrapper 。這是 virtualenv 的擴展工具，提供了一系列命令行命令，可以方便地創建，刪除，複製，切換不同的虛擬環境。同時，使用該擴展後，所有虛擬環境都會被放置在同一個目錄下。 安装 virtualenvwrapper1$ pip install virtualenvwrapper 設置環境參數把下面兩行添加到 ~/.bashrc（或者~/.zshrc） 裡。 1234if [ -f /usr/local/bin/virtualenvwrapper.sh ]; then export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.shfi 其中，.virtualenvs 是可以自定義的虛擬環境管理目錄。 然後執行：source ~/.bashrc，就可以使用 virtualenvwrapper 了。Windows 安裝過程，請参考官方文件。 使用方法創建虛擬環境： 1$ mkvirtualenv venv 注意：mkvirtualenv 也可以使用 virtualenv 的參數，比如 –python 來指定 Python 版本。創建虛擬環境後，會自動切換到此虛擬環境裡。虛擬環境目錄都在 WORKON_HOME 裡。 其他命令如下： 12345678910111213lsvirtualenv -b # 列出虛擬環境workon [環境名稱] # 切換虛擬環境lssitepackages # 查看環境中安装了哪些包cdvirtualenv [子目錄名] # 進入當前環境的目錄cpvirtualenv [source] [dest] # 複製虛擬環境deactivate # 退出虛擬環境rmvirtualenv [環境名稱] # 刪除虛擬環境","raw":null,"content":null,"categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://s2339956.github.io/tags/Python/"}]},{"title":"跳過iOS網頁視頻廣告，這樣就可以簡單做到","slug":"跳過iOS網頁視頻廣告，這樣就可以簡單做到","date":"2018-06-04T06:15:46.000Z","updated":"2018-06-05T03:32:31.000Z","comments":true,"path":"跳過iOS網頁視頻廣告，這樣就可以簡單做到.html","link":"","permalink":"http://s2339956.github.io/%E8%B7%B3%E9%81%8EiOS%E7%B6%B2%E9%A0%81%E8%A6%96%E9%A0%BB%E5%BB%A3%E5%91%8A%EF%BC%8C%E9%80%99%E6%A8%A3%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%B0%A1%E5%96%AE%E5%81%9A%E5%88%B0.html","excerpt":"　　在網頁上看一些視頻的時候，難免會遇到一些視頻廣告。這些長達30秒甚至1分鐘的視頻廣告是挺令人討厭的。那麼怎麼跳過這些煩人的廣告呢？Tin教你一個小技巧。","text":"在網頁上看一些視頻的時候，難免會遇到一些視頻廣告。這些長達30秒甚至1分鐘的視頻廣告是挺令人討厭的。那麼怎麼跳過這些煩人的廣告呢？Tin教你一個小技巧。 如何跳過視頻廣告其實iOS自帶就有跳過網頁視頻廣告的功能。視頻廣告的長短不一樣，而一般都是由幾個短的廣告拼接而成的。下面就以腾讯視頻為例： 1.在視頻廣告播放時，我們進入iOS自帶的控制中心，如圖： 2.重按或者長按控制中心的音樂播放器部件，打開音樂播放界面，如圖： 3.拖動播放界面的進度條，把進度條拖到最後，如圖： 4.回到播放的視頻網頁，發現當前廣告播完了，開始播下一個廣告了如圖： 5.有些長的廣告是由短的廣告拼接而成的，所以我們要重複上面的步驟，多拖幾次進度條，即可以跳過全部廣告了。 支援 iOS 版本實測: iphone6 10.2.1 iphoneX 11.1.2","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"Reveal 14版 環境搭建","slug":"Reveal14 使用","date":"2018-05-23T01:57:06.000Z","updated":"2018-06-05T03:32:45.000Z","comments":true,"path":"Reveal14 使用.html","link":"","permalink":"http://s2339956.github.io/Reveal14%20%E4%BD%BF%E7%94%A8.html","excerpt":"　　使用 Reveal 14版, 來看 App 裸奔～","text":"使用 Reveal 14版, 來看 App 裸奔～ 介紹Reveal 是 Mac os 平台上的一款開發者調適 iOS app 的 Mac[開發軟體]Reveal Mac 版它能夠在運行時調適和修改iOS app。Reveal 能連接到設備上的 app ，並允許開發者編輯各種用户界面參數，這反過來會立即反應在程序的 UI 上。[Reveal 在官網售價119美元，約合台幣3570元]。 搭建準備1.安裝好 Reveal2.準備一隻已越獄 iOS10 iPhone (目前工具只支持iOS8~iOS10)3.承接二項, 將設備安裝 Reveal2Loader4.承接二項, 將設備安裝 OpenSSH 環境搭建1.運行 Reveal2.點擊 help -&gt; Show Reveal Library in finder -&gt; iOS Library -&gt; RevealServer.framework, 複製路徑3.複製 RevealServer.framework 至 設備路徑 /Library/Frameworks (ssh 相關使用就不多說了～),scp -r 第二點複製的路徑 root@192.168.2.X:/Library/Frameworks (高亮的部分需修改)4.到手機設定上, 找到剛安裝的 Reveal2Loader, 選取想讓他裸奔的 App5.就能開始欣賞他裸奔囉","raw":null,"content":null,"categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://s2339956.github.io/tags/iOS/"}]},{"title":"Xcode lldb 小技能","slug":"Xcode-lldb-小技能","date":"2017-11-21T10:43:06.000Z","updated":"2017-11-22T13:16:42.000Z","comments":true,"path":"Xcode-lldb-小技能.html","link":"","permalink":"http://s2339956.github.io/Xcode-lldb-%E5%B0%8F%E6%8A%80%E8%83%BD.html","excerpt":"　　Xcode lldb 我經常使用的小伎倆","text":"Xcode lldb 我經常使用的小伎倆 使用下中斷點, 即可發現, 右下角出現 lldb 字樣, 就能開始輸入指令使用囉～ 開始使用 lldb help 指令最間單指令是 help，它會列出所有的指令。如果你忘記了一個指令是做什麼的，或者想知道更多的話，你可以聽過 help &lt;command&gt; 來離解更多，例如 help print 或者 help thread。如果你甚至忘記了 help 指令是做什麼的，你可以試試 help help。不過你如果知道怎麼做，那就說明你大概還沒有忘光這個指令。😛 打印資訊打印某些資訊時, 我習慣使用 po (print object 的縮寫), 這樣就不用每次為了得到某些資訊都得下 print or NSLog 然後重新運行 po 修改數值expression也能簡寫成 e可以動態的去修改, 某些值最常使用在, 如果在測試階段時, 想強迫它進某一個判斷使用 expression expression","raw":null,"content":null,"categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://s2339956.github.io/tags/Xcode/"}]},{"title":"2017-11-19-21:37","slug":"2017-11-19-21-37","date":"2017-11-19T13:38:00.000Z","updated":"2017-11-19T13:39:49.000Z","comments":true,"path":"2017-11-19-21-37.html","link":"","permalink":"http://s2339956.github.io/2017-11-19-21-37.html","excerpt":"","text":"我不問 + 你不說 = 這就是距離;我問了 + 你不說 = 隔閡;我問了 + 你說了 = 信任;你不說 + 我不問 = 這就是默契;我不問 + 你說了 = 這就是依賴。心若親近，言行必如流水般自然;心若疏遠，言行如如三秋之樹般蕭瑟。不怕身隔天涯，只怕心在南北。","raw":null,"content":null,"categories":[],"tags":[]},{"title":"Python join 語法使用","slug":"Python-join-語法使用","date":"2017-11-19T11:13:30.000Z","updated":"2017-11-21T10:01:16.000Z","comments":true,"path":"/Python","link":"","permalink":"http://s2339956.github.io/Python","excerpt":"　　Python 神奇的 Join 使用","text":"Python 神奇的 Join 使用 最近開始嘗試寫 blog, 記錄一些過程但每次都必須要輸入一些指令 生成 部署實在讓我有點煩, 懶惰癌無限擴張自己寫了一個 python 的小軟件讓我只要確認路徑正確, 按下確定, 就能讓它自己完成這些小事情就剛好使用了, 這個方法來打印出相關資訊 展示一下用法12345678910# 為自己 Hexo 的安装路徑hexo_install_folder = self.userinputtarget_folder_path = str(hexo_install_folder + &#x27;/source/_posts/&#x27;)# 當前目錄下所有 檔案名稱 是個陣列 Arraycur_filename_list = os.listdir(cur_folder_path)print(cur_filename_list) # 直接打印 是沒問題的# label 顯示相關訊息self.displayText[&quot;text&quot;] = &quot; &quot;.join(str(x) for x in cur_filename_list) 解釋12345678# 這邊結果會是 例如: 一個空格 加上 名稱## 具體運作是, 取得 cur_filename_list 每一個內容 轉 String, 然後在前面加上 &quot;空格&quot;## 再把他們都串起來, 變成一個字串## 簡單來說 就是## 返回值## 回傳通過指定的字串連接陣列中元素後生成的新字串&quot; &quot;.join(str(x) for x in cur_filename_list)","raw":null,"content":null,"categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://s2339956.github.io/tags/Python/"}]},{"title":"Obj-C 動態取得 Class 屬性名稱 and 屬性質值","slug":"Obj-C-動態取得-Class-屬性名稱-and-屬性質值","date":"2017-11-16T12:22:37.000Z","updated":"2018-01-05T13:24:32.000Z","comments":true,"path":"Obj-C-動態取得-Class-屬性名稱-and-屬性質值.html","link":"","permalink":"http://s2339956.github.io/Obj-C-%E5%8B%95%E6%85%8B%E5%8F%96%E5%BE%97-Class-%E5%B1%AC%E6%80%A7%E5%90%8D%E7%A8%B1-and-%E5%B1%AC%E6%80%A7%E8%B3%AA%E5%80%BC.html","excerpt":"　　Objective-C 擴充 NSArray 實現動態取得類別屬性, 縮減程式碼使用","text":"Objective-C 擴充 NSArray 實現動態取得類別屬性, 縮減程式碼使用 12345678910111213141516171819202122232425262728#import &quot;NSArray+Extension.h&quot;#import &lt;objc/runtime.h&gt; // 導入運行時文件@implementation NSArray (Extension)// 返回當前類別所有屬性+ (instancetype)getProperties:(Class)cls&#123; // 取得當前類別所以屬性 unsigned int count; // 記錄屬性個數 objc_property_t *properties = class_copyPropertyList(cls, &amp;count); // NSMutableArray *mArray = [NSMutableArray array]; for (int i = 0; i &lt; count; i++) &#123; // An opaque type that represents an Objective-C declared property. // objc_property_t 屬性類型 objc_property_t property = properties[i]; // 獲取屬性的名稱 C語言 字串 const char *cName = property_getName(property); // 轉換為 Objective C 字串 NSString *name = [NSString stringWithCString:cName encoding:NSUTF8StringEncoding]; [mArray addObject:name]; &#125; return mArray.copy;&#125;@end 使用方法1234567891011121314 for (int i = 0; i &lt;= [datas count]; i++) &#123; //取得所有屬性 ，檢查屬性值使否空 NSArray *names = [NSArray getProperties:[datas[i] class]];// #import &quot;NSArray+Extension.h&quot; 使用分類(擴充) for (NSString *name in names) &#123; // 取得Property的值 id propertyValue = [datas[i] valueForKey:name]; NSLog(@&quot;checkJoinMemberAPIPostParameter \\npropertyName: %@, propertyValue: %@&quot;, name, propertyValue); if !(propertyValue) &#123; // 如果等於空 表示沒有值 &#125; &#125; &#125;// &#125; 這種方式可以使用在, 如果你有許多欄位要判斷的時候 例如: 加入會員 Class 裡面屬性有 15 個, 每個都要填寫, 都得判斷是否有填寫,如果一般寫法可能需要 15 個 if 去判斷是否有填寫, 但這樣的寫法只要一個 if","raw":null,"content":null,"categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://s2339956.github.io/tags/Objective-C/"}]},{"title":"Xcode 中斷點 簡介","slug":"Xcode-中斷點-簡介","date":"2017-11-16T03:10:48.000Z","updated":"2021-08-30T03:27:40.474Z","comments":true,"path":"/xcode","link":"","permalink":"http://s2339956.github.io/xcode","excerpt":"Xcode 中斷點 一些簡單的介紹","text":"Xcode 中斷點 一些簡單的介紹 中斷點中斷點（breakpoint）除了普通的中斷外，還有五種特殊的形式： Exception Breakpoint：程式碼出現問題，拋出異常時觸發。 Symbolic Breakpoint：當執行某個符號時觸發。 OpenGL ES Error Breakpoint：在 OpenGL ES 錯誤發生時觸發。 Test Failure Breakpoint：測試斷言失敗的時候觸發。 Swift Error Breakpoint：在 Swift 錯誤發生時觸發。 普通中斷點：Condition：返回一個布林值，只有在布林值為 true 時才會觸發Ignore：忽略前 n 次斷點，直到第 n+1 次遇到斷點才觸發。Action：斷點觸發時，Xcode 執行的操作，如腳本等。 AppleScript：用於執行腳本，如 display dialog “SwiftGO” 彈出對話框。 Capture GPU Frame：攔截在斷點處 GPU 當前繪製的幀圖，用於 OpenGL ES 應用的調適。 Debugger Command：相當於在控制台中輸入的 lldb 調適指令。 Log Message：將自定義格式、内容的信息輸出到控制台，常用的占位符有： %H(斷點第幾次觸發)，%B(斷點所在的方法的名字) 和 @expr@(輸出expr的值)。 Shell Command：接收命令文件以及相應的參數列表。Xcode 會異步執行 ShellCommand。 勾選 “Waituntildone” 表示等待 Shell 命令執行结束後再執行調適工作。 Sound：觸發斷點的同時播放聲音。 Automatically continue after evaluating actions：勾選這個選項後，斷點不會中斷程式運行。 Swift Error Breakpoint：拋出一個繼承自 ErrorType 類型的錯誤時會觸發這個中斷點。 12345678910111213enum ThisPersonError: ErrorType &#123; case IsDead&#125;func findSomeone(name: String) throws &#123; if name &#x3D;&#x3D; &quot;xx&quot; &#123; throw ThisPersonError.IsDead &#x2F;&#x2F; 這裡將觸發中斷點 &#125;&#125;do &#123; try findSomeone(&quot;xx&quot;)&#125; 通過編輯 Swift Error Breakpoint，可以指定響應什麼類型的異常。 Exception Breakpoint：只在 Objective-C 或 C++ 中有用。比如下面這段程式碼： 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; @try &#123; &#x2F;&#x2F; 打斷點後，程式在下一行程式碼中斷 @throw [NSException exceptionWithName:@&quot;名字&quot; reason:@&quot;原因&quot; userInfo:nil]; &#125; @catch (NSException *exception) &#123; NSLog(@&quot;catch斷點&quot;); &#125; &#125; return 0;&#125; 如果不添加 Exception Breakpoint，會執行到 @catch程式碼區域。這種斷點的編輯界面和以前不太一樣： Exception： 表示響應哪種語言的異常，可以是 Objective-C 或 C++ Break：是在 throw 還是在 catch 中觸發這個異常 Symbolic Breakpoint：符號斷點會在某個方法被調用時觸發:如定義這樣的兩個函數： 1234567func burnAllCouples() &#123; print(&quot;FFF Couples&quot;)&#125;func burnAllSingleDogs() &#123; print(&quot;FFF Single Dogs&quot;)&#125; 然後把 Symbol 設置成某個函數的名字：burnAllSingleDogs，這樣每次調用 burnAllSingleDogs 函數都會觸發這個中斷點目前 Swift 中，Symbolic Breakpoint 一個比較大的問題是它不支持帶參數的方法名。 Test Failure Breakpoint這在測試的斷言失敗時觸發： 12345func testExample() &#123; XCTAssert(1 &#x3D;&#x3D; 0) &#x2F;&#x2F; This is an example of a functional test case. &#x2F;&#x2F; Use XCTAssert and related functions to verify your tests produce the correct results.&#125; 如這個測試斷言必定失敗，添加 Test Failure Breakpoint 後，程式將在 XCTAssert(1 == 0) 處中斷。","raw":null,"content":null,"categories":[],"tags":[{"name":"Xcode","slug":"Xcode","permalink":"http://s2339956.github.io/tags/Xcode/"}]},{"title":"Markdown 表格樣式調整與自適應優化","slug":"Markdown-表格樣式調整與自適應優化","date":"2017-11-15T12:39:17.000Z","updated":"2017-11-15T10:09:40.000Z","comments":true,"path":"/markdown-table-style","link":"","permalink":"http://s2339956.github.io/markdown-table-style","excerpt":"　　Markdown 寫的表格最終會被解析成 HTML 格式，如果使用的編輯器支持自定義 CSS，就能方便的調整樣式。如果可以引入 JavaScript，樣式自適應也能較好地實現。","text":"Markdown 寫的表格最終會被解析成 HTML 格式，如果使用的編輯器支持自定義 CSS，就能方便的調整樣式。如果可以引入 JavaScript，樣式自適應也能較好地實現。 See the Pen Table style by MOxFIVE (@MOxFIVE) on CodePen. 樣式調整基礎概念&lt;table&gt;: 表格 &lt;thead&gt;: table header 表頭區 &lt;th&gt;: table headings 表頭單元格内容 &lt;tbody&gt;: table body 表格内容區 &lt;tr&gt;: table row 表行 &lt;td&gt;: table data 單元格内容基本樣式123456789101112131415table &#123; width: 100%; /*表格寬度*/ max-width: 65em; /*表格最大寬度，避免表格過寬*/ border: 1px solid #dedede; /*表格外邊框設置*/ margin: 15px auto; /*外邊距*/ border-collapse: collapse; /*使用單一線條的邊框*/ empty-cells: show; /*單元格無内容依舊繪製邊框*/&#125;table th,table td &#123; height: 35px; /*統一每一行的默認高度*/ border: 1px solid #dedede; /*内部邊框樣式*/ padding: 0 10px; /*内邊距*/&#125; 表頭樣式12345table th &#123; font-weight: bold; /*加粗*/ text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 樣式覆蓋*/ background: rgba(158,188,226,0.2); /*背景色*/&#125; 隔行變色 使用選擇器選取復數行設置背景色。一般 Markdown 表格編譯後都有 &lt;tbody&gt; 包裹内容，那下面就相當於從表格第二行開始技術 123table tbody tr:nth-child(2n) &#123; background: rgba(158,188,226,0.12);&#125; 懸浮變色 滑鼠懸浮時該行改變背景色 123table tr:hover &#123; background: #efefef;&#125; 自適應優化表格用 Markdown 書寫，編輯器解析，因而只能在已經生成好的程式碼上進行自適應優化。 表頭不換行 設置表頭單元格内容不換行，這樣可以通過表頭控制該列的最小寬度，避免瀏覽器視窗缩小時内容被壓縮得太緊 123table th &#123; white-space: nowrap; /*表頭内容強制在一行顯示*/&#125; 首列不換行 表格第一列單元格内容不換行，多數情况下表格首列不應該被壓縮換行 123table td:nth-child(1) &#123; white-space: nowrap;&#125; 表格滾動條 添加 JavaScript 代碼，用一個 &lt;div&gt; 把表格包裹起来，父元素寬度不足時顯示横向滾動條，避免表格撑破布局 1234567[].slice.call(document.querySelectorAll(&#x27;table&#x27;)).forEach(function(el)&#123; var wrapper = document.createElement(&#x27;div&#x27;); wrapper.className = &#x27;table-area&#x27;; el.parentNode.insertBefore(wrapper, el); el.parentNode.removeChild(el); wrapper.appendChild(el);&#125;) jQuery 1$(&quot;table&quot;).wrap(&quot;&lt;div class=&#x27;table-area&#x27;&gt;&lt;/div&gt;&quot;); 同时添加如下 CSS 123.table-area &#123; overflow: auto;&#125; To be added","raw":null,"content":null,"categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://s2339956.github.io/tags/Markdown/"},{"name":"Table","slug":"Table","permalink":"http://s2339956.github.io/tags/Table/"},{"name":"CSS","slug":"CSS","permalink":"http://s2339956.github.io/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://s2339956.github.io/tags/JavaScript/"}]},{"title":"常用 Hexo 指令","slug":"常用-Hexo-指令","date":"2017-11-15T01:24:05.000Z","updated":"2017-11-15T01:49:38.000Z","comments":true,"path":"常用-Hexo-指令.html","link":"","permalink":"http://s2339956.github.io/%E5%B8%B8%E7%94%A8-Hexo-%E6%8C%87%E4%BB%A4.html","excerpt":"&lt;Excerpt in index | 首页摘要&gt;一些經常使用的 Hexo 指令.","text":"&lt;Excerpt in index | 首页摘要&gt;一些經常使用的 Hexo 指令.&lt;The rest of contents | 余下全文&gt; 基本指令12345$ hexo new &quot;postName&quot; # 產生新的文章$ hexo new page &quot;pageName&quot; # 產生新的頁面$ hexo clean # 清除快取檔案 (db.json) 和已產生的靜態檔案 (public)$ hexo list &lt;type&gt; # 列出網站資料$ hexo version # 顯示版本資訊 指令簡寫1234$ hexo n &#x3D;&#x3D; hexo new # 產生新的 post&#x2F;page&#x2F;draft$ hexo g &#x3D;&#x3D; hexo generate # 產生靜態文件$ hexo s &#x3D;&#x3D; hexo server # 啟動本地瀏覽$ hexo d &#x3D;&#x3D; hexo deploy # 部署文件至 Github 上 指令組合12$ hexo d -g # 產生靜態文件後，部署 blog$ hexo s -g # 產生靜態文件後，預覽 blog Hexo 官方網","raw":null,"content":null,"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://s2339956.github.io/tags/Hexo/"}]}]}